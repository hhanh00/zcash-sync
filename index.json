[{"content":"This task consists of retrieving Compact Blocks from the server and sending them downstream to the other tasks.\nLightwalletd offers a streaming interface that allows us to retrieve a range of blocks without blocking.\nThe start height is our latest synchronization height + 1. The end height is the latest block. The range can potentially be very large, but we don’t buffer more than a chunk of blocks and therefore can process large ranges.\nBlock Chunks Warp Sync does not process blocks individually but as a sub ranges of the whole synchronization range.\nWhen we receive a block, we filter out the transactions that have too many outputs/actions (Spam Filter) by clearing their output EPK and CIPHERTEXT.\nWe need to keep the CMU. They are needed for the Witness update.\nThe library queries the device available memory and adjusts the maximum number of outputs per chunk with a cap of 200 000 outputs.\nNote The outputs are counted before the spam filter.\nOtherwise, we could have an extremly high number of outputs to process in the “Update Witness” stage.\nOnce a chunk is full, we send it down through the pipeline to the next processing stage.\nInfo Download continues asynchronously in parallel with block chunk processing.\n","description":"","tags":null,"title":"Download","uri":"/execution_model/tasks/download/"},{"content":"Light Wallets ","description":"","tags":null,"title":"Light Wallets","uri":"/light_wallet/"},{"content":"The main purpose of a Light Wallet or any wallet for that matter is to provide:\nthe capability to receive funds, the capability to send funds, and display the funds available In addition, Light Wallet should be less resource-demanding than regular wallets. In the past, the latter term has been used to refer to full nodes.\nFull node wallets download the entire blockchain and keep a fairly extensive representation of the data within.\nAs of the time of writing (Sep 2022), the Zcash blockchain takes ~150 GB of storage space. It includes the Blockchain, and the database used to store the notes and transactions.\nAt the same time, a light wallet for Zcash “only” downloads 5 GB of data and keeps a few MB of storage.\nThis represents a gain of ~100X. They fit into mobile devices. They are particularly useful to the casual user.\nNote The original bitcoin paper by Satoshi mentions the idea of light wallets. He refers to them as Simplified Payment Verification wallets (SPV).\nHowever, light wallets have also some disadvantages.\nThe fact that they do not download the full blockchain prevents them from validating its content and, consequently, from participating actively in the network. They must connect to light wallet servers that have processed the blockchain on their behalf. The wallets, however, need not fully trust the servers since another form of cryptographic validation is employed. A detailed description of the threat model for wallet apps can be found here: Wallet App Threat Model.\n","description":"","tags":null,"title":"Purpose","uri":"/light_wallet/purpose/"},{"content":"There are several ways to use a warp sync in your project.\nThe simplest way is to go through the RPC API. Install and use warp sync as a server or a microservice for synchronization and account maintenance.\nIn this case, you should use the REST API published on SwaggerHub . It is also available here in the section REST API.\nBuild First of all, you have to compile the server with cargo.\nMake sure you have downloaded the ZKSNARK parameters. If you have a working installation of zcashd, the parameters are already downloaded and available. If not, use the script fetch-params.sh Then run the following command cargo b -r --bin warp-rpc --features=rpc It’s typical 100% Rust project.\nConfiguration Then set a configuration file Rocket.toml.\nallow_backup: enables the API that shows the seed phrases and should not be turned on for public servers, allow_send: enables the API that builds and signs transactions, and should also be restricted for public servers. A typical configuration file looks like:\n[default] allow_backup = false allow_send = false yec = { db_path = \"./yec.db\", lwd_url = \"https://lite.ycash.xyz:9067\" } zec = { db_path = \"./zec.db\", lwd_url = \"https://mainnet.lightwalletd.com:9067\" } Note WarpSync supports multiple coins and multiple accounts, therefore you need to set an active account before calling the account methods.\nanother way to use a websync is to you have to use the RPC so use the RPC to initiate what the synchronization and use the RPC to do payments and getting your balance also you can still use the RPC as before but then you can also access the database directly because uh the database has a is a uh meaty process and as long as you use the the proper client library and implements that has locking you should be able to uh to connect to the database in the second secondary connection and directly use the database so if you do that you have to to be mindful that only only queries are allowed should be should be should be used if you modify that the database in any way it could be you could create a problems so it’s not meant to be a to be a read write in this case you should consider database as read only but you have access to well notes accounts and uh history or this software and you can follow this keyboard that is below to uh to understand how these tables link together it’s a simple relational database with only a few a few usable tables useful tables and another way to use WAP sync is uh if you also so these two ways to use option the final way to use swapsing is what is what uh let’s see what it does which is to use it through the uh C C ffi file functional interface in this case what you would need is to compile a warp sync with the top ffi feature option which uh well the name is not really indicative exactly what he does is actually not as well it’s not 100 specific to that because it creates a CEO a C library that you can use from other languages that supports C bindings uh dot does so that’s why it’s called Dot ffi with the c bandings you can you can call from per python all these guys and uh the okay so the way to use that is uh to look take a look at uh take a look at what here at DPI and the inventory point is dot effect so you will see that in Dot ffi\nthese are one of the uh expose for sure to see and this function is called set active account and the information implementation will delegate to the real to the real rust code so these functions here are only for wrapping and unwrapping unwrapping the parameters and wrapping the results and they translate pretty simply to uh to the C parameters so coin is a is a chart u8 is a Char and Adobe URL is a C string you can see that here if the function can return an error so these functions here are either do not return anything or they return a string but if they can return an error but we return is a c result which uh which is a parameterized type for for the return the real return value and the C result is similar to our past result except that it’s a c structure that can be passed across a c boundaries uh so it’s not Union it’s always the value and error except that the error is a is a C string so if there’s are no errors if the return is correct we have a value then error would be a normal pointer and if you have an error then error would be a C string again the C string pointing to to the r message and uh it’s the uh so whenever you have a string that is returned to this to the C return to C uh it has been allocated by rust obviously but then you have to de-allocate it so there’s a function a utility function for the allocating strings that we’re allocating in in the rust uh it’s called this one the allocate Str and you’re supposed to to pass the string that you got from rust and once you’re done with it and it will uh it would be allocate so you have a bunch of these functions I’m gonna they are going to be uh oh yeah documented in rostock but the uh what they do is very similar to um to the RPC particularly RPC uh also goes through these uh this interface uh so if you don’t have to if you can use it at microservice I recommend the micro service option the RPC option because uh any you have to deal with uh with uh linking Library C libraries you know how to deal with ffi and all this stuff that is introduces I would say a necessary unnecessary complexity in in some cases in many cases and just using uh Json up API is probably enough for most of the cases and finally if you want to have there’s also what is it okay so no DPI I think somewhere\nwell maybe it’s not exposed well so let’s say that these are the only all the options for using a website and then you can use examples all right that’s it\n","description":"","tags":null,"title":"RPC","uri":"/developer/rpc/"},{"content":"In the previous section, we discusses the overall goals of scanning the blockchain. Now we are going to look at the data obtained after the scan completes.\nFrom the “largest” data to the “smallest” data:\nBlocks CREATE TABLE IF NOT EXISTS blocks ( height INTEGER PRIMARY KEY, hash BLOB NOT NULL, timestamp INTEGER NOT NULL, sapling_tree BLOB NOT NULL) First we have blocks. We keep the block:\nheight, hash and time, sapling tree The sapling tree field is unique to Zcash. The wallet needs it to update the note witnesses.\nTransactions The wallet only keeps the transactions for which it has detected either an incoming note or a spent note. Transparent transactions are not kept. They are not included in the wallet history either.\nCREATE TABLE IF NOT EXISTS transactions ( id_tx INTEGER PRIMARY KEY, account INTEGER NOT NULL, txid BLOB NOT NULL, height INTEGER NOT NULL, timestamp INTEGER NOT NULL, value INTEGER NOT NULL, address TEXT, memo TEXT, tx_index INTEGER, CONSTRAINT tx_account UNIQUE (height, tx_index, account)) id_tx: the id of the transactions. This is an internal ID only used by in our database. the account id the txid: the hash of the transaction. That’s public information the height of the block that contains this transaction. Since there can only be one block at a given height, it uniquely identifies the block too the net value of the transaction in Zats the address of the spend/destination. For transactions that involve multiple recipients that we know about, the address is arbitrary one of them. For example, if you make a transaction from your account to several of your own accounts, there will be one transaction row per account, but the destination address will just be one of the recipients the memo of one of the notes. If you make a multi-payment transaction, only one of the memos will be stored the tx_index: the position of the transaction in the block Note Multi-payment transactions are rare. That’s why the database model does not match directly with the UTXO model. Technically speaking, every UTXO has its own address and memo.\nThe Transaction table is only used for the Transaction History view. It is not used for calculating the balance or for building new transactions. In other words, it’s purely informational.\nReceived Notes On the contrary, the Received Notes table plays a critical role in defining the account state.\nCREATE TABLE IF NOT EXISTS received_notes ( id_note INTEGER PRIMARY KEY, account INTEGER NOT NULL, position INTEGER NOT NULL, tx INTEGER NOT NULL, height INTEGER NOT NULL, output_index INTEGER NOT NULL, diversifier BLOB NOT NULL, value INTEGER NOT NULL, rcm BLOB NOT NULL, nf BLOB NOT NULL UNIQUE, spent INTEGER, excluded BOOL, CONSTRAINT tx_output UNIQUE (tx, output_index)) The Received Notes table has the following columns:\nid_note: The primary key of the table account: the account ID to which this note belongs position: the absolute position of the note in the overall commitment tree. The first shielded output has position 0 and every output (regardless of its owner) increments the position. The order is determined by the order in which the output appeared in the blockchain. Unconfirmed transactions do not have a position tx: the id of the transaction (not the tx hash) height: the height of the block (same as tx height), output_index: A transaction can have multiple outputs. This is the index of the received note inside the transaction diversifier: Once decoded, we know the diversifier value that was used to derive the address. In zcash, a secret key can generate millions of addresses though many wallets just use one of them value: the amount of the note in Zats rcm: the random value used by sender when generating the output note. nf: the note nullifier. We calculate this value from the note position and the full viewing key. The note nullifier is not known by the sender spent: the block height when the note is spent. If the note is unspent, spent is NULL. If the note is spent but unconfirmed, height is equal to 0 excluded: a boolean flag that indicates if this note should be excluded from note selection when make a new payment The Received Notes table allows us to:\ncompute the account balances by summing the value of unspent notes, find which notes can be spent in new transactions rollback the blockchain when there is a reorganization Witnesses Finally, we have the note witnesses table.\nCREATE TABLE IF NOT EXISTS sapling_witnesses ( id_witness INTEGER PRIMARY KEY, note INTEGER NOT NULL, height INTEGER NOT NULL, witness BLOB NOT NULL, CONSTRAINT witness_height UNIQUE (note, height)) id_witness: The primary key of the table note: The id of the note height: The height of the witness witness: The value of the witness There is a unique witness for a given a note and a height.\n","description":"","tags":null,"title":"Tables","uri":"/data_model/tables/"},{"content":"Synchronization is made of three main tasks:\nBlock Download / Spam filtering Trial Decrypt Spend Detection Update witnesses Retrieve Transaction Details They are executed asynchroniously using the Tokio runtime.\n","description":"","tags":null,"title":"Tasks","uri":"/execution_model/tasks/"},{"content":"Welcome to the documentation website for WarpSync.\nWarpSync is a fast synchronization library for Zcash.\nOverview This documentation starts with an overview of the purpose and architecture of Lightwallets. It describes the functionalities required by a synchronization library.\nThe next section describes the Data model. Warp Sync stores its data in a SQLite Database. Each major table is shown and its purpose explained.\nThen, we show the synchronization workflow in the section Execution Model.\nFeel free to skip ahead to the developer section if you just want to use it.\nDeveloper Guide We have several integrations.\nThe easiest is to run as a web service that provides synchronization and account management.\nIt can be used as a dynamic linked library with any language that supports FFI C bindings. For an example in JAVA, go to this section.\nAnd finally, if you use rust, it is a crate that can be incorporated in your project. You will find an example here. The RustDoc is here.\n","description":"","tags":null,"title":"WarpSync","uri":"/"},{"content":"Warp Sync processes groups of sequential blocks and not blocks one by one.\nThe size of the chunks are dynamically determined and varies based on the block contents and device available resources.\nAt the end of a chunk, Warp Sync writes a checkpoint that allow a wallet to resume processing if interrupted.\nA checkpoint has the synchronization state at a given block height H:\nblock height, hash, time, etc. stored in the blocks table, transactions that were made before and including H, received and spent notes before and including H. Note Blocks between checkpoints are processed but not stored in the database.\nNote ","description":"","tags":null,"title":"Block Chunks","uri":"/data_model/chunks/"},{"content":"Data Model ","description":"","tags":null,"title":"Data Model","uri":"/data_model/"},{"content":"One of the major tasks in terms of computation is trial decryption.\nEvery output note (EPK, CIPHERTEXT, CMU) needs to be trial decrypted with every account Incoming Viewing Key (IVK).\nThere are currently more than 20 million notes (and it increases). If you have 2 accounts, it means having to trial decrypt 40 million times.\nTypically, one trial decryption takes ~1 ms (the exact time depends on your CPU). Therefore trial decryption can make up for a substantial portion of the synchronization.\nThe decryption is performed by the note-encryption crate of librustzcash.\nOptionally, on some platform WarpSync can use an alternate hardware accelerated implementation.\nThe CIPHERTEXT in the Compact Output only contains the first 52 bytes of the complete CIPHERTEXT.\nInfo Compact Outputs exclude the COUT and MEMO parts, therefore it is not possible to decrypt the memo text or the outgoing notes.\nHowever, we can identity outgoing transactions by the fact that they use one of our UTXO.\nTrial Decryption Algorithm For reference, here is an overview of the algorithm used for decrypting a compact output using an IVK.\nThe $E$ = EPK, Ephemeral Public Key is a point on the Jubjub curve serialized in compressed form. The Diffie-Hellman shared secret is $ S = E^{\\text{IVK}}$. Note that the base point $E$ differs with every note and therefore we cannot optimize the exponentiation by precomputing tables of powers of $E$. The decryption key $K$ is the Blake2b hash of $S$. The ciphertext is encrypted with Chacha20 using $K$. Once again, the CIPHERTEXT in the Compact Output only contains the first 52 bytes of the complete CIPHERTEXT.\nIt doesn’t have the memo or the authentication digest. We cannot directly check that the decrypted text is valid. However, the format of a note restricts the byte values at some offsets. For example, the first byte is the note version number. It has to be 2 since zip 212 activation.\nFurthermore, if by chance the plain note passed all format validation checks and was still invalid, it would be caught by the CMU check.\nWe can compute the plain note commitment hash (CMU) and make sure it matches the CMU from the Compact Output.\nBatch optimization Getting the affine coordinates (u, v) of EPK involves computing the inverse of a field element. We can batch multiple inversions together and only have to calculate one inverse, at the expense of having to do more multiplications. However, inversions are much more expensive than multiplications so it is still a net gain. The point exponentiation is carried out in Extended Coordinates because then we don’t have to do field inversions, and it’s faster, but we have to normalize the result and return to Affine Coordinates. This conversion uses a field inversion per point. Here again, we can batch these normalizations and use a single inversion for all the notes of a batch. Multi Threading If your CPU has several cores, trial decryption is automatically performed in parallel. We use Rayon.\nRayon is lightweight and convenient for introducing parallelism into existing code. It guarantees data-race free executions and takes advantage of parallelism when sensible, based on work-load at runtime.\n","description":"","tags":null,"title":"Decrypt","uri":"/execution_model/tasks/decrypt/"},{"content":"Non-private coins make up the vast majority of wallets. Almost all cryptocurrency users rely on them. As a result, they have come to expect a certain level of functionality and speed.\nBut private coins present significant challenges that non-private coins do not have. Because the content of the blockchain is hidden or encrypted, third party services cannot index the transactions and maintain address balances in advance.\nImagine having a dictionary where every word and definition is redacted. It would be impossible to sort the definitions by alphabetical order. Even though with zero knowledge technology, the node validators can ensure that the transaction are valid, they cannot decode the amounts and addresses of the shielded transactions.\nToday and until further progress in cryptography is made, we are presented with a dilemna:\nEither transactions are public and wallets are fast, OR transactions are hidden but wallets are slower. This is not at all specific to zcash. Every private cryptocurrency has the same issue.\nNote For private coins, wallets have to scan the blockchain to find their transactions. But for public coins, wallets can consult a server that has scanned for them.\nArguably, if you are not concerned with privacy, you could send your decryption key to a server and have it scan for you. But obviously, you need to trust that server to keep your information private.\nNote Zcash light wallets do not transmit the decryption key to a third party service and perform the decryption themselves.\n","description":"","tags":null,"title":"Privacy","uri":"/light_wallet/privacy/"},{"content":" ","description":"","tags":null,"title":"REST API","uri":"/developer/rest/"},{"content":"You can also directly query the database if you just want to leverage WarpSync for synchronization but you want to implement the wallet logic yourself.\nWarning In this workflow, you must only query the database and never update it.\nYou should use the REST API to manage accounts and perform synchronization.\nThen you can query the tables accounts, received_notes and transactions.\nAccounts CREATE TABLE IF NOT EXISTS accounts ( id_account INTEGER PRIMARY KEY, name TEXT NOT NULL, seed TEXT, aindex INTEGER NOT NULL, sk TEXT, ivk TEXT NOT NULL UNIQUE, address TEXT NOT NULL) seed: account passphrase. Can be NULL if the account was created by secret key or viewing key aindex: account sub index sk: secret key. Can be NULL if the account was created by viewing key ivk: viewing key address: shielded address Transactions, Notes, Witnesses They are documented in the Data Model\n","description":"","tags":null,"title":"Database","uri":"/developer/database/"},{"content":"Execution Model ","description":"","tags":null,"title":"Execution Model","uri":"/execution_model/"},{"content":"Warp Sync detects a reorganization when it receives a block from the server that has a previous hash different from the hash of the latest block it has.\nThis means the server has switched over to a different sequence of blocks.\nAs explained in the page about Reorganization, the wallet must rollback to a common previous state but we don’t exactly know when we deviated. Besides, we cannot rollback any number of blocks because we can apply blocks but we cannot undo a block.\nHowever, we have checkpoints and we can revert to a previous one.\nRevert to Checkpoint Every row from the blocks, transaction, received notes and witnesses table have a height value that indicates when the data was obtained. To rollback to the state after block H, we just have to delete every row that has a height greater than H.\nAnd to undo the spends that happened after H, we also need to reset the spent field of any notes if the spent height is greater than H.\nInfo Warp Sync automatically handles reorganizations.\n","description":"","tags":null,"title":"Rollback","uri":"/data_model/rollback/"},{"content":"Zcash is a Blockchain that uses the UTXO model first introduced in Bitcoin.\nUTXO Initially, every account/address has an empty balance. The only way to get coins into an account is through a transaction (TX).\nTransactions take inputs and produce outputs. Except for the mining transaction called the coinbase transaction, every transaction has inputs that fund the outputs.\nWe’ll not consider mining or minting and therefore we’ll ignore the coinbase transaction.\nNotes Inputs and outputs are notes. They have an amount and belong to an address. The address is associated with a secret key that let’s you use the note as an input of a transaction. If you do not have the secret key, you cannot to spend the output.\nFor public coins, notes are in clear text. By analyzing the blockchain, one can calculate the balance of every address in use. They just need to tally every incoming note and deduct every spent note.\nHowever, Zcash has both public and private notes. Public notes behave exactly like explained above but private notes are encrypted.\nEncrypted notes also have an amount and an address but this information is not readable unless you have a viewing key.\nNote Without the right viewing key, an encrypted note appears as random bytes. Encrypted notes are also called shielded notes.\nIt may be worth remembering that a note belong to a single address but an address may own any number of notes.\nUnspent Transaction Outputs (UTXO) UTXO are the notes that haven’t been spent yet.\nTheir total is the amount of coins in circulation. The UTXO for which you have the secret key are the funds you can spend.\nTherefore it is very important that your wallet keeps track of all the UTXO you can spend.\nThe only way to know which UTXO are yours is to scan the blockchain and look at every transaction inputs and outputs.\nTransparent UTXO If the UTXO belong to a transparent address, a wallet can leverage an external service, for example a block explorer, and delegate the scan. The service can scan the Blockchain once and track every transparent UTXO in a database.\nNote Zcashd can index every transaction and keep a track of every transparent address ever used.\nThis requires address storage and processing power, therefore zcashd needs to run with the txindex=1 option.\nShielded UTXO Shielded UTXO cannot be indexed by an external service or by zcashd. zcashd knows about your shielded UTXO but it cannot possibly decrypt other users’ encrypted notes.\nTherefore, your wallet must scan the blockchain itself.\nInfo To determine the balance of your shielded address, your wallet MUST scan the blockchain.\n","description":"","tags":null,"title":"UTXO Model","uri":"/light_wallet/utxo/"},{"content":"Note Commitments When someone makes a transactions and therefore creates output notes, they are encrypted. Even when they are spent, notes are not revealed because that would also give the transaction that created them.\nIn fact, we could imagine a scheme where the notes are not stored in the blockchain but only the zk proofs. Of course, it implies that clients have another way to retrieve the encrypted output if they don’t store it themselves.\nIn any case, the point is that when a transaction output, or note is created we cannot blindly trust that it does not double spend or just has a value that exceeds the inputs.\nIn a public blockchain, full nodes can verify every transaction and ensure that they are well-formed. But if the transaction is encrypted, it is impossible to check them.\nThanks for zero knowledge proofs, we have now the technology to create cryptographic proofs that the outputs follow the protocol rules without knowing precisely their value.\nBut the ZKP is not enough. When we want to spend one of our note, we must also show that what we spend is indeed a previously unspent output.\nThe usual tool for that is the cryptographic commitment.\nWhenever you want to show that you know something but you don’t want to reveal it at the moment, you can use a commitment.\nA commitment scheme works in two phases.\nYou “commit” to your value by calculating a “commitment value”. You publish this value for everyone to see. When you want to show that you have the value, you reveal it and people can check that the commitment value matches the published commitment. For it to work, the commitment value must be:\nbinding: You must reveal the right value. If you reveal something else, the commitment value will not match. hiding: The commitment value is public but it must not give any information that could reveal the source value. Note In Zcash, the note commitments ensure that when the notes are used, they refer to outputs of previous transactions.\nOutput notes are encrypted but their commitments are public.\nNote Commitment Tree Note commitments are put in the Blockchain and the order in which they appear defines the order in which they added to a binary tree of height 63. This tree is called the Note Commitment Tree. Every zcash node agrees on the same commitment tree since it only contains public information.\nThis tree has millions of leaves. They are never removed or modified. Therefore the tree keeps growing and is not prunable at the moment.\nIf you receive a note from a transaction, the note is yours and you have the note that matches the commitment. However, only a small fraction of all the note commitments are yours. The rest belong to other users.\nWhen you want to spend a note, you must prove that it was a previous transaction output. The way you prove that is by showing that the note commitment is in the tree.\nNow, showing that your note is in the tree without telling which note it is, is difficult.\nIt requires some cryptographic tools.\nMerkle Tree We want to show that we have the note that matches a commitment that was transmitted earlier and is now part of the tree.\nThis will also explain why the note commitments are stored as a tree and now as a plain list.\nThe note commitment tree is organized as a binary tree. For each non-terminal node, i.e. internal node, there are two children. The tree has a fixed depth of 63, for a total of 2^63 commitments. However, at this moment, there are about 20-30 million notes used. The vast majority of the leaves are unused. Unused leaves have a commitment value of [0; 32] (32 bytes of 00).\nThe inner nodes are hashes of the two children. Since each child is a hash value (the leaf is also a hash value), they all have a size of 32 bytes.\nNote To get the value of an inner node, concatenate the hash value of the left node and the right node to form a 64 byte sequence and hash it.\nHere’s a small general Merkle Tree: It has only 3 levels and therefore can store $2^3=8$ elements\nIn the case of the Merkle Tree for the note commitments (NCT), the layer $T_x$ is omitted because the data are already hashes.\nEx: $H_{EF} = \\text{Hash}(H_E, H_F)$, where the Hash function is defined in the next section.\n$$H_{ABCD} = \\text{Hash}(H_{AB}, H_{CD})$$ $$H_{ABCDEFGH} = \\text{Hash}(H_{ABCD}, H_{EFGH})$$\nAlso, the NCT stores notes incrementally: previous entries are never removed or modified. We just assign an empty slot to a new commitment in the order they appear in the blockchain.\nWe can see that the root of the tree, $H_{ABCDEFGH}$ depends on the value of every note commitment.\nEvery time a new note gets added, the root hash will change. And because all the nodes are hash values, it is impossible to predict in advance the root value.\nAlso, the NCT is tracked by every network participant and is part of consensus. We can query the current root hash from zcashd.\nIf we were only interested in the security of the note commitments, we wouldn’t need to build a Merkle Tree. We could simply build a list from all the note commitments and hash them at once, as a sequence of bytes. If any of the commitment is altered, the overall hash would also change.\nInstead of having all these intermediate hashes, we would have a single hash value that combines all the hashes together. The calculation would be much faster because only one hash would have to be computed.\nBut a Merkle Tree has a major advantage if you want to prove that a value belongs to the set of hashes.\nIf you had the hash of the list, to prove that a value is part of that list, you must:\ngive every value of the list, have the verifier calculate the hash check it equals the “official” root hash check that the value you provided is in the list Obviously, Giving 20-30 million hash values is not practical.\nWith a Merkle Tree, we can reduce that amount of data to only 63 hashes.\nLet’s say we want to prove that $H_E$ is part of the tree.\nWe start by giving $H_E$. In this scenario, the receiver does not have $H_x$ but only knows the root hash.\nIn addition to $H_E$, we also give the “Merkle Path”, which is the list of the sibling hashes from the leaf to the root\nIn our case, that would be $H_F$, $H_{GH}$, $H_{ABCD}$. The direct path is $H_E$, $H_{EF}$ and $H_{EFGH}$, but we want the siblings.\nThe receiver/verifier can then recompute the direct path using the Merkle Path:\n$H_{EF} = h(H_E, H_F)$, $H_{EFGH} = h(H_{EF}, H_{GH})$, $H_{ABCDEFGH} = h(H_{ABCD}, H_{EFGH})$ The last hash is the root. If it matches, $H_E$ belongs to the tree.\nWe cannot fool the verifier because every data we provide is a hash. A main property of the hash function is that it computationnally impossible to find different values $(a, b)$ than $(H_E, H_F)$ such as $H_{EF} = h(a, b)$\nTherefore we are forced to give the real hash values if we want to match the root hash.\nIn Zcash, this Merkle Path is an input to the Spend Statement ZKP that we cover briefly in the last section.\nPedersen Hash As you can, the NCT contains a large number of hashes and needs to be updated every time a new note is added. The hash function used is a Pedersen Hash.\nThe Pedersen Hash function securely maps a sequence of bits into a point on an elliptical curve, (Jubjub for Sapling).\nIt is much more expensive to compute a Pedersen Hash than to compute a SHA or a Blake hash, due to the finite field arithmetic involved.\nBut it can be implemented in a ZK circuit more efficiently than a classic hash function.\nWitnesses For every UTXO that your wallet has, the app needs to update the Merkle Path when we receive new outputs. Even if none of the outputs are ours. With the growth of transaction outputs, we have now several million notes that have to be processed in every wallet.\nWarp Sync Optimizations The main goal of Warp Sync is to minimize Pedersen Hash calculations and especially avoid recalculating the same hash twice.\nWhen you have several notes in your wallet, there is a good chance that they have part of their Merkle Path in common. A non-optimized implementation would treat each note independently and update the witnesses by recomputing their Merkle Path sequentially.\nWarp Sync rebuilds the Merkle Tree in parallel, and distributes the hash values to the note. It ensures that the calculation are spread out across all the CPU core and that the witness updates are essentially data copies.\nAnother advantage of doing hash calculations on the NCT instead of on the witnesses, is that WS can use a cryptographic optimization, that reduces the number of field divisions.\nSpend Statement ZKP In the case of Zcash, the Merkle Path is not published and stored in the blockchain but serves as a secret input to the ZKP spend statements. Essentially, we state that we know the Merkle Path for the note we spend but we don’t reveal it.\n","description":"","tags":null,"title":"Witnesses","uri":"/execution_model/tasks/witnesses/"},{"content":"Developer How to use Warp Sync in your own projects\n","description":"","tags":null,"title":"Developer","uri":"/developer/"},{"content":"You can build the Warp Sync library as a dynamic library and use it from your code as long as it supports interfacing with native code.\nMost programming languages have the ability to call into C code. Therefore, you should be able to use FFI (Foreign Function Interface).\nIn this section, we’ll describe the low-level C API.\nBuild First edit the file Cargo.toml and change the library type from rlib to cdylib Then compile: cargo b -r --features=dart_ffi This should create a dynamic library in the target/release directory. On Linux, the file is named libwarp_api_ffi.so. Other platforms have slightly different names.\nEven if your programming language is not DART, the feature is dart_ffi for historical reasons.\nHeader file The C header file is binding.h\n","description":"","tags":null,"title":"FFI","uri":"/developer/ffi/"},{"content":"","description":"","tags":null,"title":"Pipeline","uri":"/execution_model/tasks/pipeline/"},{"content":"Scanning the blockchain can be done in several ways. Ultimately they all achieve the same goal:\nDetermine which notes you received, ie adding incoming funds, Cross-out the notes you spent, ie substracting outgoing funds, And finally, allowing you to spend your UTXO. The first two bullet points are typical of any UTXO based cryptocurrency wallet, but the last bullet point may be unusual.\nNote Once the blockchain scan finishes, your wallet is said to be synchronized.\nIn most cryptocurrencies, as long as you have the secret key and a reference to the UTXO, you can spend it.\nThis is not the case of Zcash.\nTo spend a shielded UTXO, your wallet must also keep track of a value called the “witness” specific to a given note and block height. In other words, every note has a witness which is a several hundred byte long that changes every time we get a new block.\nWhen the wallet wants to spend a note, it needs to compute a “proof” of validity called a zero knowledge proof (ZKP). The ZKP ensures that we have the secret key and the reference to the UTXO without actually disclosing this information.\nZKP Creation Function One of the argument of the ZKP creation function is the witness. Therefore, if you want to spend a note, the wallet needs to compute its witness at a given height.\nWallets are not obligated to provide the latest witnesses. But since the height is public information, if a wallet does not update the witnesses it would be possible to gain some knowledge by looking at the witness heights of a transaction.\nNote If a wallet does not update the note witnesses, one can check the height when a note is spent and deduce when it was received.\nNullifiers In Bitcoin, to spend a UTXO, a wallet simply has to refer to it and attach a digital signature proving it knows the secret key.\nIn Zcash, UTXO are encrypted. But that’s not enough. Spending a UTXO must also be hidden. If Zcash transactions referred to UTXO like Bitcoin does, one could know when the UTXO was created. Therefore even if it would be impossible to know the values and addresses of the notes, it would be possible to link notes with transactions.\nTo avoid this, Zcash transactions do not directly refer to UTXO but they refer to a nullifier instead.\nNullifiers are unique values associated with a note. Only the receiver of the note can create the nullifier and it’s impossible to make a nullifier for a note that does not exist. The exact mechanism used to achieve this is beyond the scope of this document.\nNote Each UTXO has a unique nullifier. Nullifiers cannot be faked: Anyone can verify that a nullifier is associated with a real UTXO.\nScan Outputs In conclusion, let’s review what a scan must do:\nIt must scan each transaction and try to decrypt its outputs. Successful decryptions generate “received notes” (fresh UTXO). For each received note, the wallet can calculate its nullifier. Spent notes are detected when their nullifier is used in a later transaction. For each UTXO, the wallet maintains a witness that it should keep updating. ","description":"","tags":null,"title":"Scan / Sync","uri":"/light_wallet/scan/"},{"content":"Example using Java Checkout the integrations/java directory for an example of how to use JAVA with Warp Sync to create a new account and query the seed phrase and address.\nMain class package app.ywallet; import java.sql.*; /** */ public class App { static { System.loadLibrary(\"java_warp\"); } public static void main( String[] args ) throws Exception { Class.forName(\"org.sqlite.JDBC\"); final App app = new App(); // Create a new account final int id = app.newAccount(); // Connect to the database via JDBC Connection conn = DriverManager.getConnection(\"jdbc:sqlite:zec.db\"); // Query the seed and address of the account by id String query = \"SELECT seed, address FROM accounts WHERE id_account = ?\"; PreparedStatement statement = conn.prepareStatement(query); statement.setInt(1, id); ResultSet rs = statement.executeQuery(); while (rs.next()) { String seed = rs.getString(1); String address = rs.getString(2); System.out.println(\"seed phrase: \" + seed + \", address: \" + address); } } private native int newAccount(); } JNI Wrapper The JNI wrapper calls new_account and returns the new account id. In a more realistic case, the wallet would be initialized only once and the account name would be passed in.\nJNIEXPORT jint JNICALL Java_app_ywallet_App_newAccount (JNIEnv *, jobject) { init_wallet((char *)\".\"); CResult_u32 result = new_account(0, (char *)\"test\", (char*)\"\", 0); return result.value; } Makefile The Makefile builds the JNI library that should be copied into the JAVA lib path.\nlibjava_warp.so: app_ywallet_App.o: app_ywallet_App.cpp g++ -c -fPIC -I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux app_ywallet_App.cpp libjava_warp.so: app_ywallet_App.o g++ -shared -fPIC -o libjava_warp.so app_ywallet_App.o -L/usr/lib -lwarp_api_ffi ","description":"","tags":null,"title":"Java","uri":"/developer/java/"},{"content":"Reorganizations happen when several miners submit different blocks at the same height.\nIt is a rare occurence but it happens.\nFor example, if you have the following situation:\nMiner A submits block 1001 after block 1000 Miner B submits a different block 1001 Miner C submits a block 1002 based on miner B’s block 1001 Now we have two chains that deviate at block 1000:\none built from Miner A’s block 1001 the other from Miner B’s block 1001 and Miner C’s 1002 Since nodes cannot determine a-priori which chains will get longer after seeing block 1001, some of them first follow Miner A while others follow Miner B.\nBut when Miner C produces block 1002, Miner B’s chain is now longer than Miner A’s.\nInfo Nodes have to follow the longest chain.\nWhen nodes that were following Miner A’s chain see the blocks from Miner B and C’s chain, they must switch over.\nThis is called a block reorganization. Note that the nodes that were already following Miner B and C do not switch. Therefore, a block reorganization is a local event.\nAfter effects When a node has to perform a block reorganization, it must undo the effects of the blocks that are no longer valid. In this case, Miner A’s block 1001. Every transaction from that block must be undone:\nnotes that were spent are returned new notes that were created are destroyed In other words, the node should return to the point before Miner A’s block 1001 and process Miner B’s block 1001 instead. Then it should continue with Miner C’s block 1002.\nFailure to handle reorganization leads to incorrect state, so it’s paramount that a wallet can undo a previously applied block.\nHowever, in normal situation reorganizations are short lived. It is very unlikely to have a reorganization longer than a few blocks.\nWe assume that reorganizations are always shorter than 100 blocks.\n","description":"","tags":null,"title":"Reorganization","uri":"/light_wallet/reorg/"},{"content":"Documentation The API has its own documentation pages.\nExample using Rust Checkout the integrations/rust directory for an example of how to use JAVA with Warp Sync to create a new account and query the seed phrase and address.\nuse warp_api_ffi::api::account::{get_backup, new_account}; use warp_api_ffi::api::sync::coin_sync; use warp_api_ffi::{CoinConfig, init_coin, set_coin_lwd_url}; use lazy_static::lazy_static; use std::sync::Mutex; lazy_static! { static ref CANCEL: Mutex\u003cbool\u003e = Mutex::new(false); } const FVK: \u0026str = \"zxviews1q0duytgcqqqqpqre26wkl45gvwwwd706xw608hucmvfalr759ejwf7qshjf5r9aa7323zulvz6plhttp5mltqcgs9t039cx2d09mgq05ts63n8u35hyv6h9nc9ctqqtue2u7cer2mqegunuulq2luhq3ywjcz35yyljewa4mgkgjzyfwh6fr6jd0dzd44ghk0nxdv2hnv4j5nxfwv24rwdmgllhe0p8568sgqt9ckt02v2kxf5ahtql6s0ltjpkckw8gtymxtxuu9gcr0swvz\"; #[tokio::main] async fn main() { env_logger::init(); // Initialize the library for Zcash (coin = 0) init_coin(0, \"./zec.db\").unwrap(); set_coin_lwd_url(0, \"https://lwdv3.zecwallet.co:443\"); // ZecWallet Lightwalletd URL // Create a new account with the ZEC pages viewing key let id_account = new_account(0, \"test_account\", Some(FVK.to_string()), None).unwrap(); // Synchronize coin_sync(0 /* zcash */, true /* retrieve tx details */, 0 /* sync to tip */, 100 /* spam filter threshold */, |p| { log::info!(\"Progress: {}\", p.height); }, \u0026CANCEL).await.unwrap(); // Grab the database accessor let cc = \u0026CoinConfig::get(0 /* zcash */); let db = cc.db.as_ref().unwrap().clone(); let db = db.lock().unwrap(); // Query the account balance let balance = db.get_balance(id_account).unwrap(); println!(\"Balance = {}\", balance) } ","description":"","tags":null,"title":"Rust","uri":"/developer/rust/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/"}]