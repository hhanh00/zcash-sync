[{"content":"This task consists of retrieving Compact Blocks from the server and sending them downstream to the other tasks.\nLightwalletd offers a streaming interface that allows us to retrieve a range of blocks without blocking.\nThe start height is our latest synchronization height + 1. The end height is the latest block. The range can potentially be very large, but we don’t buffer more than a chunk of blocks and therefore can process large ranges.\nBlock Chunks Warp Sync does not process blocks individually but as a sub ranges of the whole synchronization range.\nWhen we receive a block, we filter out the transactions that have too many outputs/actions (Spam Filter) by clearing their output EPK and CIPHERTEXT.\nWe need to keep the CMU. They are needed for the Witness update.\nThe library queries the device available memory and adjusts the maximum number of outputs per chunk with a cap of 200 000 outputs.\nNote The outputs are counted before the spam filter.\nOtherwise, we could have an extremly high number of outputs to process in the “Update Witness” stage.\nOnce a chunk is full, we send it down through the pipeline to the next processing stage.\nInfo Download continues asynchronously in parallel with block chunk processing.\n","description":"","tags":null,"title":"Download","uri":"/execution_model/tasks/download/"},{"content":"Light Wallets ","description":"","tags":null,"title":"Light Wallets","uri":"/light_wallet/"},{"content":"Zcash unified addresses make creating transactions more complex than before.\nIn the past, an address corresponded to a single receiver and was tied to a specific type of note. For example, a z-addr is a sapling address and only receives sapling funds. A unified address may contain more than one receiver. Simply put, it combines several legacy addresses.\nWhen the user wants to pay to a unified address, the wallet app has to determine which unspent transaction outputs it can use to minimize information leakage. As a result, the wallet may decide to automatically split a payment.\nLet’s take this example. Alice has 100 ZEC in her wallet. 60 ZEC in combined sapling notes and 40 ZEC in combined orchard notes. She wants to send 50 ZEC to Bob.\nBob gives her a z-addr. The wallet will build a transaction from Alice’s sapling pool because it has sufficient funds.\nIf instead, Bob gives a unified address with only an Orchard receiver, Alice does not have enough Orchard funds. She has 40 ZEC but needs 50 ZEC. She can decide to take 10 ZEC from her sapling funds, but it will reveal a transfer of 10 ZEC on the Blockchain. If she does not want to reveal any amount, the transaction cannot be made.\nLet’s say she’s ok with revealing amounts. The wallet can split the payment into two outputs: 40 ZEC from Orchard + 10 ZEC from Sapling. 10 ZEC moved from Sapling to Orchard. Her wallet now has 50 ZEC remaining in the sapling pool.\nAlternatively, since she’s OK with revealing amounts, the wallet can now use a single output: 50 ZEC from Sapling. But she will reveal that 50 ZEC has migrated from Sapling to Orchard.\nNow if Bob gives a unified address that has both Sapling and Orchard receivers, the wallet can spend:\n50 ZEC from Sapling, or 40 ZEC from Orchard + 10 ZEC from Sapling and many other combinations No amount is revealed since no funds have crossed pools.\nMore complex cases can occur when the transaction has multiple recipients and/or involves transparent funds as well.\nIn the next section, we’ll discuss the inputs and settings to the transaction building algorithm. We want to keep the settings understandable.\n","description":"","tags":null,"title":"Overview","uri":"/note_selection/overview/"},{"content":"The main purpose of a Light Wallet or any wallet for that matter is to provide:\nthe capability to receive funds, the capability to send funds, and display the funds available In addition, Light Wallet should be less resource-demanding than regular wallets. In the past, the latter term has been used to refer to full nodes.\nFull node wallets download the entire blockchain and keep a fairly extensive representation of the data within.\nAs of the time of writing (Sep 2022), the Zcash blockchain takes ~150 GB of storage space. It includes the Blockchain, and the database used to store the notes and transactions.\nAt the same time, a light wallet for Zcash “only” downloads 5 GB of data and keeps a few MB of storage.\nThis represents a gain of ~100X. They fit into mobile devices. They are particularly useful to the casual user.\nNote The original bitcoin paper by Satoshi mentions the idea of light wallets. He refers to them as Simplified Payment Verification wallets (SPV).\nHowever, light wallets have also some disadvantages.\nThe fact that they do not download the full blockchain prevents them from validating its content and, consequently, from participating actively in the network. They must connect to light wallet servers that have processed the blockchain on their behalf. The wallets, however, need not fully trust the servers since another form of cryptographic validation is employed. A detailed description of the threat model for wallet apps can be found here: Wallet App Threat Model.\n","description":"","tags":null,"title":"Purpose","uri":"/light_wallet/purpose/"},{"content":"There are several ways to use a warp sync in your project.\nThe simplest way is to go through the RPC API. Install and use warp sync as a server or a microservice for synchronization and account maintenance.\nIn this case, you should use the REST API published on SwaggerHub . It is also available here in the section REST API.\nBuild First of all, you have to compile the server with cargo.\nMake sure you have downloaded the ZKSNARK parameters. If you have a working installation of zcashd, the parameters are already downloaded and available. If not, use the script fetch-params.sh Then run the following command cargo b -r --bin warp-rpc --features=rpc It’s typical 100% Rust project.\nConfiguration Then set a configuration file Rocket.toml.\nallow_backup: enables the API that shows the seed phrases and should not be turned on for public servers, allow_send: enables the API that builds and signs transactions, and should also be restricted for public servers. A typical configuration file looks like:\n[default] allow_backup = false allow_send = false yec = { db_path = \"./yec.db\", lwd_url = \"https://lite.ycash.xyz:9067\" } zec = { db_path = \"./zec.db\", lwd_url = \"https://mainnet.lightwalletd.com:9067\" } Note WarpSync supports multiple coins and multiple accounts, therefore you need to set an active account before calling the account methods.\n","description":"","tags":null,"title":"RPC","uri":"/developer/rpc/"},{"content":"In the previous section, we discusses the overall goals of scanning the blockchain. Now we are going to look at the data obtained after the scan completes.\nFrom the “largest” data to the “smallest” data:\nBlocks CREATE TABLE IF NOT EXISTS blocks ( height INTEGER PRIMARY KEY, hash BLOB NOT NULL, timestamp INTEGER NOT NULL, sapling_tree BLOB NOT NULL) First we have blocks. We keep the block:\nheight, hash and time, sapling tree The sapling tree field is unique to Zcash. The wallet needs it to update the note witnesses.\nTransactions The wallet only keeps the transactions for which it has detected either an incoming note or a spent note. Transparent transactions are not kept. They are not included in the wallet history either.\nCREATE TABLE IF NOT EXISTS transactions ( id_tx INTEGER PRIMARY KEY, account INTEGER NOT NULL, txid BLOB NOT NULL, height INTEGER NOT NULL, timestamp INTEGER NOT NULL, value INTEGER NOT NULL, address TEXT, memo TEXT, tx_index INTEGER, CONSTRAINT tx_account UNIQUE (height, tx_index, account)) id_tx: the id of the transactions. This is an internal ID only used by in our database. the account id the txid: the hash of the transaction. That’s public information the height of the block that contains this transaction. Since there can only be one block at a given height, it uniquely identifies the block too the net value of the transaction in Zats the address of the spend/destination. For transactions that involve multiple recipients that we know about, the address is arbitrary one of them. For example, if you make a transaction from your account to several of your own accounts, there will be one transaction row per account, but the destination address will just be one of the recipients the memo of one of the notes. If you make a multi-payment transaction, only one of the memos will be stored the tx_index: the position of the transaction in the block Note Multi-payment transactions are rare. That’s why the database model does not match directly with the UTXO model. Technically speaking, every UTXO has its own address and memo.\nThe Transaction table is only used for the Transaction History view. It is not used for calculating the balance or for building new transactions. In other words, it’s purely informational.\nReceived Notes On the contrary, the Received Notes table plays a critical role in defining the account state.\nCREATE TABLE IF NOT EXISTS received_notes ( id_note INTEGER PRIMARY KEY, account INTEGER NOT NULL, position INTEGER NOT NULL, tx INTEGER NOT NULL, height INTEGER NOT NULL, output_index INTEGER NOT NULL, diversifier BLOB NOT NULL, value INTEGER NOT NULL, rcm BLOB NOT NULL, nf BLOB NOT NULL UNIQUE, spent INTEGER, excluded BOOL, CONSTRAINT tx_output UNIQUE (tx, output_index)) The Received Notes table has the following columns:\nid_note: The primary key of the table account: the account ID to which this note belongs position: the absolute position of the note in the overall commitment tree. The first shielded output has position 0 and every output (regardless of its owner) increments the position. The order is determined by the order in which the output appeared in the blockchain. Unconfirmed transactions do not have a position tx: the id of the transaction (not the tx hash) height: the height of the block (same as tx height), output_index: A transaction can have multiple outputs. This is the index of the received note inside the transaction diversifier: Once decoded, we know the diversifier value that was used to derive the address. In zcash, a secret key can generate millions of addresses though many wallets just use one of them value: the amount of the note in Zats rcm: the random value used by sender when generating the output note. nf: the note nullifier. We calculate this value from the note position and the full viewing key. The note nullifier is not known by the sender spent: the block height when the note is spent. If the note is unspent, spent is NULL. If the note is spent but unconfirmed, height is equal to 0 excluded: a boolean flag that indicates if this note should be excluded from note selection when make a new payment The Received Notes table allows us to:\ncompute the account balances by summing the value of unspent notes, find which notes can be spent in new transactions rollback the blockchain when there is a reorganization Witnesses Finally, we have the note witnesses table.\nCREATE TABLE IF NOT EXISTS sapling_witnesses ( id_witness INTEGER PRIMARY KEY, note INTEGER NOT NULL, height INTEGER NOT NULL, witness BLOB NOT NULL, CONSTRAINT witness_height UNIQUE (note, height)) id_witness: The primary key of the table note: The id of the note height: The height of the witness witness: The value of the witness There is a unique witness for a given a note and a height.\n","description":"","tags":null,"title":"Tables","uri":"/data_model/tables/"},{"content":"Synchronization is made of three main tasks:\nBlock Download / Spam filtering Trial Decrypt Spend Detection Update witnesses Retrieve Transaction Details They are executed asynchroniously using the Tokio runtime.\n","description":"","tags":null,"title":"Tasks","uri":"/execution_model/tasks/"},{"content":"Welcome to the documentation website for WarpSync.\nWarpSync is a fast synchronization library for Zcash.\nOverview This documentation starts with an overview of the purpose and architecture of Lightwallets. It describes the functionalities required by a synchronization library.\nThe next section describes the Data model. Warp Sync stores its data in a SQLite Database. Each major table is shown and its purpose explained.\nThen, we show the synchronization workflow in the section Execution Model.\nFeel free to skip ahead to the developer section if you just want to use it.\nDeveloper Guide We have several integrations.\nThe easiest is to run as a web service that provides synchronization and account management.\nWarpSync can be used as a dynamic linked library from any language that supports FFI C bindings. For an example in JAVA, go to this section.\nAnd finally, if you use rust, WarpSync is a crate that can be incorporated in your project. You will find an example here. The RustDoc is here.\n","description":"","tags":null,"title":"WarpSync","uri":"/"},{"content":"Warp Sync processes groups of sequential blocks and not blocks one by one.\nThe size of the chunks are dynamically determined and varies based on the block contents and device available resources.\nAt the end of a chunk, Warp Sync writes a checkpoint that allow a wallet to resume processing if interrupted.\nA checkpoint has the synchronization state at a given block height H:\nblock height, hash, time, etc. stored in the blocks table, transactions that were made before and including H, received and spent notes before and including H. Note Blocks between checkpoints are processed but not stored in the database.\n","description":"","tags":null,"title":"Block Chunks","uri":"/data_model/chunks/"},{"content":"Data Model ","description":"","tags":null,"title":"Data Model","uri":"/data_model/"},{"content":"One of the major tasks in terms of computation is trial decryption.\nEvery output note (EPK, CIPHERTEXT, CMU) needs to be trial decrypted with every account Incoming Viewing Key (IVK).\nThere are currently more than 20 million notes (and it increases). If you have 2 accounts, it means having to trial decrypt 40 million times.\nTypically, one trial decryption takes ~1 ms (the exact time depends on your CPU). Therefore trial decryption can make up for a substantial portion of the synchronization.\nThe decryption is performed by the note-encryption crate of librustzcash.\nOptionally, on some platform WarpSync can use an alternate hardware accelerated implementation.\nThe CIPHERTEXT in the Compact Output only contains the first 52 bytes of the complete CIPHERTEXT.\nInfo Compact Outputs exclude the COUT and MEMO parts, therefore it is not possible to decrypt the memo text or the outgoing notes.\nHowever, we can identity outgoing transactions by the fact that they use one of our UTXO.\nTrial Decryption Algorithm For reference, here is an overview of the algorithm used for decrypting a compact output using an IVK.\nThe $E$ = EPK, Ephemeral Public Key is a point on the Jubjub curve serialized in compressed form. The Diffie-Hellman shared secret is $ S = E^{\\text{IVK}}$. Note that the base point $E$ differs with every note and therefore we cannot optimize the exponentiation by precomputing tables of powers of $E$. The decryption key $K$ is the Blake2b hash of $S$. The ciphertext is encrypted with Chacha20 using $K$. Once again, the CIPHERTEXT in the Compact Output only contains the first 52 bytes of the complete CIPHERTEXT.\nIt doesn’t have the memo or the authentication digest. We cannot directly check that the decrypted text is valid. However, the format of a note restricts the byte values at some offsets. For example, the first byte is the note version number. It has to be 2 since zip 212 activation.\nFurthermore, if by chance the plain note passed all format validation checks and was still invalid, it would be caught by the CMU check.\nWe can compute the plain note commitment hash (CMU) and make sure it matches the CMU from the Compact Output.\nBatch optimization Getting the affine coordinates (u, v) of EPK involves computing the inverse of a field element. We can batch multiple inversions together and only have to calculate one inverse, at the expense of having to do more multiplications. However, inversions are much more expensive than multiplications so it is still a net gain. The point exponentiation is carried out in Extended Coordinates because then we don’t have to do field inversions, and it’s faster, but we have to normalize the result and return to Affine Coordinates. This conversion uses a field inversion per point. Here again, we can batch these normalizations and use a single inversion for all the notes of a batch. Multi Threading If your CPU has several cores, trial decryption is automatically performed in parallel. We use Rayon.\nRayon is lightweight and convenient for introducing parallelism into existing code. It guarantees data-race free executions and takes advantage of parallelism when sensible, based on work-load at runtime.\n","description":"","tags":null,"title":"Decrypt","uri":"/execution_model/tasks/decrypt/"},{"content":"Non-private coins make up the vast majority of wallets. Almost all cryptocurrency users rely on them. As a result, they have come to expect a certain level of functionality and speed.\nBut private coins present significant challenges that non-private coins do not have. Because the content of the blockchain is hidden or encrypted, third party services cannot index the transactions and maintain address balances in advance.\nImagine having a dictionary where every word and definition is redacted. It would be impossible to sort the definitions by alphabetical order. Even though with zero knowledge technology, the node validators can ensure that the transaction are valid, they cannot decode the amounts and addresses of the shielded transactions.\nToday and until further progress in cryptography is made, we are presented with a dilemna:\nEither transactions are public and wallets are fast, OR transactions are hidden but wallets are slower. This is not at all specific to zcash. Every private cryptocurrency has the same issue.\nNote For private coins, wallets have to scan the blockchain to find their transactions. But for public coins, wallets can consult a server that has scanned for them.\nArguably, if you are not concerned with privacy, you could send your decryption key to a server and have it scan for you. But obviously, you need to trust that server to keep your information private.\nNote Zcash light wallets do not transmit the decryption key to a third party service and perform the decryption themselves.\n","description":"","tags":null,"title":"Privacy","uri":"/light_wallet/privacy/"},{"content":" ","description":"","tags":null,"title":"REST API","uri":"/developer/rest/"},{"content":"To make a payment, we take funds from notes we received previously but haven’t spent yet and we send the funds to the receipients’ addresses.\nInputs Our inputs are the UTXO (for transparent funds), Sapling notes and Orchard notes. Notes from different types are not directly fungible, but we can make a transaction that uses several types of notes. Also, notes must be used as a whole. We cannot use a fraction of a note. However, we can make outputs that send the funds back to the origin address. This mimics the behavior of classic bank notes and coins.\nWe use the term UTXO for any kind of note, whether transparent, Sapling or Orchard.\nSettings The transaction builder has the following settings:\nPrivacy Policy: determines which kind of information leaking is allowed, if any. SamePoolTypeOnly by default Use Transparent Source: if true, the transaction can use transparent funds. False by default Pool Usage Priority: See below. (Orchard, Sapling, Transparent) by default Change Address: the address where the change is sent. It can be a Unified Address that has multiple receivers. Address of the sender’s account by default Privacy Policy From the strictest policy to the loosest policy\nSamePoolOnly. Funds cannot leave their pool: t2t, sapling to sapling, orchard to orchard SamePoolTypeOnly. Funds can travel from one shielded pool to the other AnyPool. We do what it takes to build the transaction Pool Usage Order The pool usage order is the order in which we take funds from the source. For example, if we have: 10 ZEC in each pool and we want to spend 15 ZEC,\nwhen the pool priority is TSO, we take first from Transparent, then Sapling, then Orchard. Therefore: 10 is taken from Transparent and 5 from Sapling. when the pool priority is OST, we take first from Orchard, then Sapling, then Transparent. Therefore: 10 is taken from Orchard and 5 from Sapling. Note that the “Use Transparent Source” takes priority over “Pool Usage Priority”. If it’s unchecked, then we will not use transparent funds at all.\nFees and Change Fees are calculated based on the current network rules:\neither as a constant 1000 zats, or as ZIP-317 (pending) The change follows the same policy rules as other recipients. Therefore, it may get split into several outputs.\n","description":"","tags":null,"title":"Settings","uri":"/note_selection/settings/"},{"content":"You can also directly query the database if you just want to leverage WarpSync for synchronization but you want to implement the wallet logic yourself.\nWarning In this workflow, you must only query the database and never update it.\nYou should use the REST API to manage accounts and perform synchronization.\nThen you can query the tables accounts, received_notes and transactions.\nAccounts CREATE TABLE IF NOT EXISTS accounts ( id_account INTEGER PRIMARY KEY, name TEXT NOT NULL, seed TEXT, aindex INTEGER NOT NULL, sk TEXT, ivk TEXT NOT NULL UNIQUE, address TEXT NOT NULL) seed: account passphrase. Can be NULL if the account was created by secret key or viewing key aindex: account sub index sk: secret key. Can be NULL if the account was created by viewing key ivk: viewing key address: shielded address Transactions, Notes, Witnesses They are documented in the Data Model\n","description":"","tags":null,"title":"Database","uri":"/developer/database/"},{"content":"Execution Model ","description":"","tags":null,"title":"Execution Model","uri":"/execution_model/"},{"content":"Warp Sync detects a reorganization when it receives a block from the server that has a previous hash different from the hash of the latest block it has.\nThis means the server has switched over to a different sequence of blocks.\nAs explained in the page about Reorganization, the wallet must rollback to a common previous state but we don’t exactly know when we deviated. Besides, we cannot rollback any number of blocks because we can apply blocks but we cannot undo a block.\nHowever, we have checkpoints and we can revert to a previous one.\nRevert to Checkpoint Every row from the blocks, transaction, received notes and witnesses table have a height value that indicates when the data was obtained. To rollback to the state after block H, we just have to delete every row that has a height greater than H.\nAnd to undo the spends that happened after H, we also need to reset the spent field of any notes if the spent height is greater than H.\nInfo Warp Sync automatically handles reorganizations.\n","description":"","tags":null,"title":"Rollback","uri":"/data_model/rollback/"},{"content":"Zcash is a Blockchain that uses the UTXO model first introduced in Bitcoin.\nUTXO Initially, every account/address has an empty balance. The only way to get coins into an account is through a transaction (TX).\nTransactions take inputs and produce outputs. Except for the mining transaction called the coinbase transaction, every transaction has inputs that fund the outputs.\nWe’ll not consider mining or minting and therefore we’ll ignore the coinbase transaction.\nNotes Inputs and outputs are notes. They have an amount and belong to an address. The address is associated with a secret key that let’s you use the note as an input of a transaction. If you do not have the secret key, you cannot to spend the output.\nFor public coins, notes are in clear text. By analyzing the blockchain, one can calculate the balance of every address in use. They just need to tally every incoming note and deduct every spent note.\nHowever, Zcash has both public and private notes. Public notes behave exactly like explained above but private notes are encrypted.\nEncrypted notes also have an amount and an address but this information is not readable unless you have a viewing key.\nNote Without the right viewing key, an encrypted note appears as random bytes. Encrypted notes are also called shielded notes.\nIt may be worth remembering that a note belong to a single address but an address may own any number of notes.\nUnspent Transaction Outputs (UTXO) UTXO are the notes that haven’t been spent yet.\nTheir total is the amount of coins in circulation. The UTXO for which you have the secret key are the funds you can spend.\nTherefore it is very important that your wallet keeps track of all the UTXO you can spend.\nThe only way to know which UTXO are yours is to scan the blockchain and look at every transaction inputs and outputs.\nTransparent UTXO If the UTXO belong to a transparent address, a wallet can leverage an external service, for example a block explorer, and delegate the scan. The service can scan the Blockchain once and track every transparent UTXO in a database.\nNote Zcashd can index every transaction and keep a track of every transparent address ever used.\nThis requires address storage and processing power, therefore zcashd needs to run with the txindex=1 option.\nShielded UTXO Shielded UTXO cannot be indexed by an external service or by zcashd. zcashd knows about your shielded UTXO but it cannot possibly decrypt other users’ encrypted notes.\nTherefore, your wallet must scan the blockchain itself.\nInfo To determine the balance of your shielded address, your wallet MUST scan the blockchain.\n","description":"","tags":null,"title":"UTXO Model","uri":"/light_wallet/utxo/"},{"content":"Note Commitments When someone makes a transactions and therefore creates output notes, they are encrypted. Even when they are spent, notes are not revealed because that would also give the transaction that created them.\nIn fact, we could imagine a scheme where the notes are not stored in the blockchain but only the zk proofs. Of course, it implies that clients have another way to retrieve the encrypted output if they don’t store it themselves.\nIn any case, the point is that when a transaction output, or note is created we cannot blindly trust that it does not double spend or just has a value that exceeds the inputs.\nIn a public blockchain, full nodes can verify every transaction and ensure that they are well-formed. But if the transaction is encrypted, it is impossible to check them.\nThanks for zero knowledge proofs, we have now the technology to create cryptographic proofs that the outputs follow the protocol rules without knowing precisely their value.\nBut the ZKP is not enough. When we want to spend one of our note, we must also show that what we spend is indeed a previously unspent output.\nThe usual tool for that is the cryptographic commitment.\nWhenever you want to show that you know something but you don’t want to reveal it at the moment, you can use a commitment.\nA commitment scheme works in two phases.\nYou “commit” to your value by calculating a “commitment value”. You publish this value for everyone to see. When you want to show that you have the value, you reveal it and people can check that the commitment value matches the published commitment. For it to work, the commitment value must be:\nbinding: You must reveal the right value. If you reveal something else, the commitment value will not match. hiding: The commitment value is public but it must not give any information that could reveal the source value. Note In Zcash, the note commitments ensure that when the notes are used, they refer to outputs of previous transactions.\nOutput notes are encrypted but their commitments are public.\nNote Commitment Tree Note commitments are put in the Blockchain and the order in which they appear defines the order in which they added to a binary tree of height 63. This tree is called the Note Commitment Tree. Every zcash node agrees on the same commitment tree since it only contains public information.\nThis tree has millions of leaves. They are never removed or modified. Therefore the tree keeps growing and is not prunable at the moment.\nIf you receive a note from a transaction, the note is yours and you have the note that matches the commitment. However, only a small fraction of all the note commitments are yours. The rest belong to other users.\nWhen you want to spend a note, you must prove that it was a previous transaction output. The way you prove that is by showing that the note commitment is in the tree.\nNow, showing that your note is in the tree without telling which note it is, is difficult.\nIt requires some cryptographic tools.\nMerkle Tree We want to show that we have the note that matches a commitment that was transmitted earlier and is now part of the tree.\nThis will also explain why the note commitments are stored as a tree and now as a plain list.\nThe note commitment tree is organized as a binary tree. For each non-terminal node, i.e. internal node, there are two children. The tree has a fixed depth of 63, for a total of 2^63 commitments. However, at this moment, there are about 20-30 million notes used. The vast majority of the leaves are unused. Unused leaves have a commitment value of [0; 32] (32 bytes of 00).\nThe inner nodes are hashes of the two children. Since each child is a hash value (the leaf is also a hash value), they all have a size of 32 bytes.\nNote To get the value of an inner node, concatenate the hash value of the left node and the right node to form a 64 byte sequence and hash it.\nHere’s a small general Merkle Tree: It has only 3 levels and therefore can store $2^3=8$ elements\nIn the case of the Merkle Tree for the note commitments (NCT), the layer $T_x$ is omitted because the data are already hashes.\nEx: $H_{EF} = \\text{Hash}(H_E, H_F)$, where the Hash function is defined in the next section.\n$$H_{ABCD} = \\text{Hash}(H_{AB}, H_{CD})$$ $$H_{ABCDEFGH} = \\text{Hash}(H_{ABCD}, H_{EFGH})$$\nAlso, the NCT stores notes incrementally: previous entries are never removed or modified. We just assign an empty slot to a new commitment in the order they appear in the blockchain.\nWe can see that the root of the tree, $H_{ABCDEFGH}$ depends on the value of every note commitment.\nEvery time a new note gets added, the root hash will change. And because all the nodes are hash values, it is impossible to predict in advance the root value.\nAlso, the NCT is tracked by every network participant and is part of consensus. We can query the current root hash from zcashd.\nIf we were only interested in the security of the note commitments, we wouldn’t need to build a Merkle Tree. We could simply build a list from all the note commitments and hash them at once, as a sequence of bytes. If any of the commitment is altered, the overall hash would also change.\nInstead of having all these intermediate hashes, we would have a single hash value that combines all the hashes together. The calculation would be much faster because only one hash would have to be computed.\nBut a Merkle Tree has a major advantage if you want to prove that a value belongs to the set of hashes.\nIf you had the hash of the list, to prove that a value is part of that list, you must:\ngive every value of the list, have the verifier calculate the hash check it equals the “official” root hash check that the value you provided is in the list Obviously, Giving 20-30 million hash values is not practical.\nWith a Merkle Tree, we can reduce that amount of data to only 63 hashes.\nLet’s say we want to prove that $H_E$ is part of the tree.\nWe start by giving $H_E$. In this scenario, the receiver does not have $H_x$ but only knows the root hash.\nIn addition to $H_E$, we also give the “Merkle Path”, which is the list of the sibling hashes from the leaf to the root\nIn our case, that would be $H_F$, $H_{GH}$, $H_{ABCD}$. The direct path is $H_E$, $H_{EF}$ and $H_{EFGH}$, but we want the siblings.\nThe receiver/verifier can then recompute the direct path using the Merkle Path:\n$H_{EF} = h(H_E, H_F)$, $H_{EFGH} = h(H_{EF}, H_{GH})$, $H_{ABCDEFGH} = h(H_{ABCD}, H_{EFGH})$ The last hash is the root. If it matches, $H_E$ belongs to the tree.\nWe cannot fool the verifier because every data we provide is a hash. A main property of the hash function is that it computationnally impossible to find different values $(a, b)$ than $(H_E, H_F)$ such as $H_{EF} = h(a, b)$\nTherefore we are forced to give the real hash values if we want to match the root hash.\nIn Zcash, this Merkle Path is an input to the Spend Statement ZKP that we cover briefly in the last section.\nPedersen Hash As you can, the NCT contains a large number of hashes and needs to be updated every time a new note is added. The hash function used is a Pedersen Hash.\nThe Pedersen Hash function securely maps a sequence of bits into a point on an elliptical curve, (Jubjub for Sapling).\nIt is much more expensive to compute a Pedersen Hash than to compute a SHA or a Blake hash, due to the finite field arithmetic involved.\nBut it can be implemented in a ZK circuit more efficiently than a classic hash function.\nWitnesses For every UTXO that your wallet has, the app needs to update the Merkle Path when we receive new outputs. Even if none of the outputs are ours. With the growth of transaction outputs, we have now several million notes that have to be processed in every wallet.\nWarp Sync Optimizations The main goal of Warp Sync is to minimize Pedersen Hash calculations and especially avoid recalculating the same hash twice.\nWhen you have several notes in your wallet, there is a good chance that they have part of their Merkle Path in common. A non-optimized implementation would treat each note independently and update the witnesses by recomputing their Merkle Path sequentially.\nWarp Sync rebuilds the Merkle Tree in parallel, and distributes the hash values to the note. It ensures that the calculation are spread out across all the CPU core and that the witness updates are essentially data copies.\nAnother advantage of doing hash calculations on the NCT instead of on the witnesses, is that WS can use a cryptographic optimization, that reduces the number of field divisions.\nSpend Statement ZKP In the case of Zcash, the Merkle Path is not published and stored in the blockchain but serves as a secret input to the ZKP spend statements. Essentially, we state that we know the Merkle Path for the note we spend but we don’t reveal it.\n","description":"","tags":null,"title":"Witnesses","uri":"/execution_model/tasks/witnesses/"},{"content":" Info Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s assume we choose (Transparent, Sapling, Orchard) in the Pool Usage Order which means we’d rather use our Transparent notes first and keep our Orchard notes.\nSuppose we have the following notes:\nT: 50 S: 50 O: 50 Let’s consider the following order:\norder # T S O 1 10 The number is the quantity for a given address type.\nOrder 1 is a t-addr for 10 Settings Note In order to do a T2T, we must enable use_transparent\nNote Selection We begin with (50, 50, 50) in each pool respectively.\nOrder 1: we use 10 from T-pool. Now we have (40, 50, 50) Fee ZIP 327 In the T-pool, we have\n1 inputs, 1 output for Order #1 In the S-pool, we have\n0 input, 0 outputs In the O-pool, we have\n0 inputs, 0 outputs T-pool contributes 1 logical actions = max(1, 1) S-pool contributes 0 logical actions O-pool contributes 0 logical actions The number of logical actions = 1 and the fee is 1 * 5 = 5\nHowever, we haven’t paid for the fee, and we haven’t considered the change outputs yet.\nPaying for the fee and making change outputs We pay for the fee using 5 from T-pool, following our pool usage preferences.\nWe also have change outputs:\nT: we used 50, pay 10+5 and we should get 35 back, This output adds up to the transaction and modify the fee.\nT-pool contributes 2 logical actions = max(1, 2) S-pool contributes 0 logical actions O-pool contributes 0 logical actions The number of logical actions = 2 and the fee is 2 * 5 = 10\nLet’s adjust for the new fee.\nT: we used 50, pay 10+10 and we should get 30 back, Final transaction Inputs: T: 50 Outputs: Order 1: T/10 Change: T/30 Fee: 10 ","description":"","tags":null,"title":"Example 1: T2T","uri":"/note_selection/example01/"},{"content":" Info Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s assume we choose (Transparent, Sapling, Orchard) in the Pool Usage Order which means we’d rather use our Transparent notes first and keep our Orchard notes.\nSuppose we have the following notes:\nT: 50 S: 50 O: 50 Let’s consider the following order:\norder # T S O 1 10 The number is the quantity for a given address type.\nOrder 1 is a z-addr for 10 Note Selection We begin with (50, 50, 50) in each pool respectively.\nOrder 1: we use 10 from S-pool. Now we have (50, 40, 50) Fee ZIP 327 In the T-pool, we have\n0 inputs, 0 outputs In the S-pool, we have\n0 input, 1 output for Order #1 In the O-pool, we have\n0 inputs, 0 outputs T-pool contributes 0 logical actions S-pool contributes 1 logical actions = max(1, 1) O-pool contributes 0 logical actions The number of logical actions = 1 and the fee is 1 * 5 = 5\nHowever, we haven’t paid for the fee, and we haven’t considered the change outputs yet.\nPaying for the fee and making change outputs We pay for the fee using 5 from S-pool, following our pool usage preferences.\nNote If we follow the pool usage preferences exactly, we should be using T-inputs, but they are disabled by default.\nWe also have change outputs:\nS: we used 50, pay 10+5 and we should get 35 back, This output adds up to the transaction and modify the fee.\nT-pool contributes 0 logical actions S-pool contributes 2 logical actions = max(1, 2) O-pool contributes 0 logical actions The number of logical actions = 2 and the fee is 2 * 5 = 10\nLet’s adjust for the new fee.\nS: we used 50, pay 10+10 and we should get 30 back, Final transaction Inputs: S: 50 Outputs: Order 1: S/10 Change: S/30 Fee: 10 ","description":"","tags":null,"title":"Example 2: Z2Z (Sapling)","uri":"/note_selection/example02/"},{"content":" Info Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s assume we choose (Transparent, Sapling, Orchard) in the Pool Usage Order which means we’d rather use our Transparent notes first and keep our Orchard notes.\nSuppose we have the following notes:\nT: 50 S: 50 O: 50 Let’s consider the following order:\norder # T S O 1 10 The number is the quantity for a given address type.\nOrder 1 is a ua-addr with only an orchard receiver for 10 Note Selection We begin with (50, 50, 50) in each pool respectively.\nOrder 1: we use 10 from O-pool. Now we have (50, 50, 40) Fee ZIP 327 In the T-pool, we have\n0 inputs, 0 outputs In the S-pool, we have\n0 inputs, 0 outputs In the O-pool, we have\n0 input, 1 output for Order #1 T-pool contributes 0 logical actions S-pool contributes 0 logical actions O-pool contributes 1 logical actions = max(1, 1) The number of logical actions = 1 and the fee is 1 * 5 = 5\nHowever, we haven’t paid for the fee, and we haven’t considered the change outputs yet.\nPaying for the fee and making change outputs We pay for the fee using 5 from O-pool, following our pool usage preferences.\nNote If we follow the pool usage preferences exactly, we should be using T-inputs, but they are disabled by default. Then, the S-pool but that would involve a pool we haven’t touched yet. In order to reduce fees, the algorithm picks up the pools that are already used.\nWe also have change outputs:\nO: we used 50, pay 10+5 and we should get 35 back, This output adds up to the transaction and modify the fee.\nT-pool contributes 0 logical actions S-pool contributes 0 logical actions O-pool contributes 2 logical actions = max(1, 2) The number of logical actions = 2 and the fee is 2 * 5 = 10\nLet’s adjust for the new fee.\nO: we used 50, pay 10+10 and we should get 30 back, Final transaction Inputs: S: 50 Outputs: Order 1: O/10 Change: O/30 Fee: 10 ","description":"","tags":null,"title":"Example 3: Z2Z (Orchard)","uri":"/note_selection/example03/"},{"content":" Info Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s assume we choose (Transparent, Sapling, Orchard) in the Pool Usage Order which means we’d rather use our Transparent notes first and keep our Orchard notes.\nSuppose we have the following notes:\nT: 50 S: 50 O: 50 Let’s consider the following order:\norder # T S O 1 10 The number is the quantity for a given address type.\nSettings Note By default, the transaction will not cross from shielded to transparent. We need to set the privacy policy to AnyPool.\nNote Selection We begin with (50, 50, 50) in each pool respectively.\nOrder 1: we use 10 from S-pool. Now we have (50, 40, 50) Fee ZIP 327 In the T-pool, we have\n0 inputs, 1 output for Order #1 In the S-pool, we have\n1 input, 0 output In the O-pool, we have\n0 input, 0 output T-pool contributes 1 logical actions S-pool contributes 1 logical actions O-pool contributes 0 logical actions The number of logical actions = 2 and the fee is 2 * 5 = 10\nHowever, we haven’t paid for the fee, and we haven’t considered the change outputs yet.\nPaying for the fee and making change outputs We pay for the fee using 5 from S-pool, following our pool usage preferences.\nNote If we follow the pool usage preferences exactly, we should be using T-inputs, but they are disabled by default.\nWe also have change outputs:\nS: we used 50, pay 10+5 and we should get 35 back, This output adds up to the transaction and modify the fee.\nT-pool contributes 1 logical actions S-pool contributes 1 logical actions = max(1, 1) O-pool contributes 0 logical actions The number of logical actions = 2 and the fee is 2 * 5 = 10\nLet’s adjust for the new fee.\nS: we used 50, pay 10+10 and we should get 30 back, Final transaction Inputs: S: 50 Outputs: Order 1: T/10 Change: S/30 Fee: 10 ","description":"","tags":null,"title":"Example 4: Z2T (Sapling)","uri":"/note_selection/example04/"},{"content":" Info Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nSuppose we have the following notes:\nT: 50 S: 50 O: 50 Let’s consider the following order:\norder # T S O 1 10 The number is the quantity for a given address type.\nSettings Note By default, the transaction will not cross from shielded to transparent. We need to set the privacy policy to AnyPool.\nThe pool usage should also prefer Orchard over Sapling. For example, we can use (Transparent, Orchard, Sapling) as the Pool Usage Order.\nNote Selection We begin with (50, 50, 50) in each pool respectively.\nOrder 1: we use 10 from S-pool. Now we have (50, 50, 40) Fee ZIP 327 In the T-pool, we have\n0 inputs, 1 output for Order #1 In the S-pool, we have\n0 input, 0 output In the O-pool, we have\n1 input, 0 output T-pool contributes 1 logical actions S-pool contributes 0 logical actions O-pool contributes 1 logical actions The number of logical actions = 2 and the fee is 2 * 5 = 10\nHowever, we haven’t paid for the fee, and we haven’t considered the change outputs yet.\nPaying for the fee and making change outputs We pay for the fee using 5 from O-pool, following our pool usage preferences.\nWe also have change outputs:\nO: we used 50, pay 10+5 and we should get 35 back, This output adds up to the transaction and modify the fee.\nT-pool contributes 1 logical actions S-pool contributes 0 logical actions O-pool contributes 1 logical actions = max(1, 1) The number of logical actions = 2 and the fee is 2 * 5 = 10\nLet’s adjust for the new fee.\nO: we used 50, pay 10+10 and we should get 30 back, Final transaction Inputs: O: 50 Outputs: Order 1: T/10 Change: O/30 Fee: 10 ","description":"","tags":null,"title":"Example 5: Z2T (Orchard)","uri":"/note_selection/example05/"},{"content":" Info Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s assume we choose (Transparent, Sapling, Orchard) in the Pool Usage Order which means we’d rather use our Transparent notes first and keep our Orchard notes.\nSuppose we have the following notes:\nT: 50 S: 50 O: 50 Let’s consider the following order:\norder # T S O 1 10 The number is the quantity for a given address type.\nSettings Note By default, the transaction will not cross from shielded to transparent. We need to set the privacy policy to AnyPool.\nWe should enable the usage of the transparent pool and disable the usage of the shielded pool.\nOtherwise, the transaction will be z2z as it is more private than a t2z.\nWe’ll skip the detailed explanation from now on.\nFinal transaction Inputs: T: 50 Outputs: Order 1: S/10 Change: T/30 Fee: 10 ","description":"","tags":null,"title":"Example 6: T2Z (Sapling)","uri":"/note_selection/example06/"},{"content":" Info Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s assume we choose (Transparent, Sapling, Orchard) in the Pool Usage Order which means we’d rather use our Transparent notes first and keep our Orchard notes.\nSuppose we have the following notes:\nT: 50 S: 50 O: 50 Let’s consider the following order:\norder # T S O 1 10 The number is the quantity for a given address type.\nSettings Note By default, the transaction will be directly Orchard to Orchard.\nWe must exclude the Orchard notes if we want a Sapling to Orchard transaction.\nOtherwise, the transaction will be z2z as it is more private than a t2z.\nWe’ll skip the detailed explanation from now on.\nFinal transaction Inputs: S: 50 Outputs: Order 1: O/10 Change: S/30 Fee: 10 The change always goes back to the origin pool.\n","description":"","tags":null,"title":"Example 7: Z2Z (Sap/Orc)","uri":"/note_selection/example07/"},{"content":"Summary This example demonstrates the iterative process towards finding a suitable set of notes. Fees are calculated based on the structure of the transaction, but they also impact the transaction. Therefore, the algorithm needs to try out several combinations.\nInfo Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s consider the following orders:\norder # T S O 1 10 The number is the quantity for a given address type. If a row has more than one set of numbers, it’s the total amount.\nOrder 1 is a t-addr for 10 Suppose we have the following notes:\nT: 5, 7 S: 12 O: 10 Note Selection Let’s assume we choose (Sapling, Orchard, Transparent) in the Pool Usage Order and the change address is a UA with Transparent and Sapling receivers.\nWe begin with (12, 12, 10) in each pool respectively.\nOrder 1: we use 10 from T-pool. Now we have (2, 12, 10) Fee ZIP 327 In the T-pool, we have\n2 inputs, 1 output for Order #1 In the S-pool, we have\n0 input, 0 outputs In the O-pool, we have\n0 inputs, 0 outputs T-pool contributes 2 logical actions = max(2, 1). S-pool contributes 0 logical actions O-pool contributes 0 logical actions The number of logical actions = 2 and the fee is 2 * 5 = 10\nHowever, we haven’t paid for the fee, and we haven’t considered the change outputs yet.\nPaying for the fee and making change outputs We pay for the fee using 10 from T\u0026S-pool, following our pool usage preferences.\nWe also have change outputs:\nT: we use 12 (= 5+7), pay 10 to order #1 and 2 for fees, S: we use 12, pay 8 in fees, and we should get 4 back. These outputs add up to the transaction and modify the fee.\nT-pool contributes 2 logical actions = max(2, 1). S-pool contributes 1 logical actions = max(1, 1). O-pool contributes 0 logical actions The number of logical actions = 3 and the fee is 3 * 5 = 15\nLet’s adjust for the new fee.\nBut we can only pay 12 from the S-pool. We need to use the O-pool too now.\nT: pay 2 for fees. No T-change S: pay 12 for fees. No more S-change O: pay 1 for fees, get 9 in change We have to add an orchard action!\nT-pool contributes 2 logical actions = max(2, 2). S-pool contributes 1 logical actions = max(1, 0). O-pool contributes 1 logical actions The number of logical actions = 4 and the fee is 4 * 5 = 20\nWe need to pay 5 more from the O-pool since the S-pool is empty.\nT: pay 2 for fees. No T-change S: pay 12 for fees. No S-change O: pay 6 for fees, get 4 in change At last, we are not modifying the transaction structure anymore.\nFinal transaction Inputs: all notes are used T: 5, 7 S: 12 O: 10 Outputs: Order 1: T/10 Change: O/4 Fee: 20 ","description":"","tags":null,"title":"Example 8 - Iterative Search","uri":"/note_selection/example08/"},{"content":"Summary This is the same as the previous example but we disable transparent inputs. The transaction fails because it cannot pay for the fees.\nInfo Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s consider the following orders:\norder # T S O 1 10 The number is the quantity for a given address type.\nOrder 1 is a t-addr for 10 Suppose we have the following notes:\nT: 0 S: 12 O: 10 Note Selection Let’s assume we choose (Sapling, Orchard, Transparent) in the Pool Usage Order.\nWe begin with (0, 12, 10) in each pool respectively.\nOrder 1: we use 10 from S-pool. Now we have (0, 2, 10) Fee ZIP 327 In the T-pool, we have\n0 input, 1 output for Order #1 In the S-pool, we have\n1 input, 0 output In the O-pool, we have\n0 input, 0 output T-pool contributes 1 logical actions = max(0, 1). S-pool contributes 1 logical actions = max(1, 0). O-pool contributes 0 logical actions The number of logical actions = 2 and the fee is 2 * 5 = 10\nHowever, we haven’t paid for the fee, and we haven’t considered the change outputs yet.\nPaying for the fee and making change outputs We pay for the fee using 2 from S-pool and 8 from O-pool, following our pool usage preferences.\nWe also have change outputs:\nS: we used 12, pay 10 to Order #1, pay 2 in fees, we get 0 change O: we used 10, pay 8 in fees, we get 2 in change These outputs add up to the transaction and modify the fee.\nT-pool contributes 1 logical actions = max(0, 1). S-pool contributes 1 logical actions = max(1, 0). O-pool contributes 1 logical actions The number of logical actions = 3 and the fee is 3 * 5 = 15\nLet’s adjust for the new fee.\nBut we cannot pay the additional 5 in fees since we only have 2 left.\nFinal transaction Transaction failed because of unsufficient funds (cannot pay fees)\nIf we add another orchard note worth 10, we get the final transaction:\nInputs: all notes are used S: 12 O: 10, 10 Outputs: Order 1: T/10 Change: O/2 Fee: 20 The analysis is left as an exercise.\nHint:\nT-pool contributes 1 logical actions = max(0, 1). S-pool contributes 1 logical actions = max(1, 0). O-pool contributes 2 logical actions = max(2, 1) ","description":"","tags":null,"title":"Example 9 - Failure","uri":"/note_selection/example09/"},{"content":"Developer How to use Warp Sync in your own projects\n","description":"","tags":null,"title":"Developer","uri":"/developer/"},{"content":"Summary This example combines multiple orders of different address types. It also demonstrates how the algorithm handles multiple receivers in a unified address.\nInfo Amounts are in kzats (1 kzats = 1000 zats = 0.01 mZEC)\nLet’s consider the following orders:\norder # T S O 1 10 2 20 3 30 4 40 40 5 50 50 6 60 60 7 70 70 70 The number is the quantity for a given address type. If a row has more than one set of numbers, it’s the total amount.\nOrder 1 is a t-addr for 10 Order 4 is a ua with transparent and sapling receivers for 40 Order 7 is a ua with transparent, sapling and orchard receivers for 70 in total across T, S and O receivers Suppose we have the following notes:\nT: 100 S: 160 O: 70 \u0026 50 Note Selection Let’s assume we choose (Sapling, Orchard, Transparent) in the Pool Usage Order and the change address is a UA with Transparent and Sapling receivers.\nWe begin with (100, 160, 120) in each pool respectively.\nOrder 1: we use 10 from T-pool. Now we have (90, 160, [70, 50]) Order 2: we use 20 from S-pool. Now we have (90, 140, [70, 50]) Order 3: we use 30 from O-pool. Now we have (90, 140, [40, 50]) Order 4: we use 30 from S-pool. S is preferred over T. Now we have (90, 100, [40, 50]). Order 5: we use 50 from O-pool. O is preferred over T. Now we have (90, 100, 40). Order 6: we use 60 from O-pool. S is preferred over O. Now we have (90, 40, 40). Order 7: we use 40 from S-pool and 30 from the O-pool. S is preferred over O, but we don’t have enough and we need the O-pool too. Now we have (90, 0, 10). Fee ZIP 327 In the T-pool, we have\n1 input, 1 output for Order #1 In the S-pool, we have\n1 input, 4 outputs for Order #2, #4, #6, #7 In the O-pool, we have\n2 inputs, 3 outputs for Order #3, #5, #7 T-pool contributes 1 logical actions = max(1, 1). S-pool contributes 4 logical actions = max(1, 4) O-pool contributes 3 logical actions = max(2, 3) The number of logical actions = 8 and the fee is 8 * 5 = 40\nHowever, we haven’t paid for the fee, and we haven’t considered the change outputs yet.\nPaying for the fee and making change outputs We pay for the fee using 10 from O-pool and 30 from T-pool, following our pool usage preferences.\nSo now, we should have (60, 0, 0). But we spent all our inputs therefore, we need a change output of 60 to our t-addr.\nThis T-output increases the number of T-logical actions to 2 = max(1, 2). Then the total number of logical actions is now 9. The fee becomes 45.\nThe change is also adjusted to 55.\nFinal transaction Inputs: all notes are used T: 100 S: 160 O: 70 \u0026 50 Outputs: Order 1: T/10 Order 2: S/20 Order 3: O/30 Order 4: S/40 Order 5: O/50 Order 6: S/60 Order 7: S/40, O/30 Change: T/55 Fee: 45 Test Code fn test_example10() { env_logger::init(); let mut config = NoteSelectConfig::new(CHANGE_ADDRESS); config.use_transparent = true; config.privacy_policy = PrivacyPolicy::AnyPool; config.precedence = [ Pool::Sapling, Pool::Orchard, Pool::Transparent ]; let utxos = [utxo!(1, 100), sapling!(2, 160), orchard!(3, 70), orchard!(4, 50)]; let mut orders = [t!(1, 10), s!(2, 20), o!(3, 30), ts!(4, 40), to!(5, 50), so!(6, 60), tso!(7, 70)]; let tx_plan = note_select_with_fee::\u003cFeeZIP327\u003e(\u0026utxos, \u0026mut orders, \u0026config).unwrap(); println!(\"{}\", serde_json::to_string(\u0026tx_plan).unwrap()); } ","description":"","tags":null,"title":"Example 10 - Multi Payments","uri":"/note_selection/example10/"},{"content":"You can build the Warp Sync library as a dynamic library and use it from your code as long as it supports interfacing with native code.\nMost programming languages have the ability to call into C code. Therefore, you should be able to use FFI (Foreign Function Interface).\nIn this section, we’ll describe the low-level C API.\nBuild First edit the file Cargo.toml and change the library type from rlib to cdylib Then compile: cargo b -r --features=dart_ffi This should create a dynamic library in the target/release directory. On Linux, the file is named libwarp_api_ffi.so. Other platforms have slightly different names.\nEven if your programming language is not DART, the feature is dart_ffi for historical reasons.\nHeader file The C header file is binding.h\n","description":"","tags":null,"title":"FFI","uri":"/developer/ffi/"},{"content":"","description":"","tags":null,"title":"Note Selection","uri":"/note_selection/"},{"content":"","description":"","tags":null,"title":"Pipeline","uri":"/execution_model/tasks/pipeline/"},{"content":"Scanning the blockchain can be done in several ways. Ultimately they all achieve the same goal:\nDetermine which notes you received, ie adding incoming funds, Cross-out the notes you spent, ie substracting outgoing funds, And finally, allowing you to spend your UTXO. The first two bullet points are typical of any UTXO based cryptocurrency wallet, but the last bullet point may be unusual.\nNote Once the blockchain scan finishes, your wallet is said to be synchronized.\nIn most cryptocurrencies, as long as you have the secret key and a reference to the UTXO, you can spend it.\nThis is not the case of Zcash.\nTo spend a shielded UTXO, your wallet must also keep track of a value called the “witness” specific to a given note and block height. In other words, every note has a witness which is a several hundred byte long that changes every time we get a new block.\nWhen the wallet wants to spend a note, it needs to compute a “proof” of validity called a zero knowledge proof (ZKP). The ZKP ensures that we have the secret key and the reference to the UTXO without actually disclosing this information.\nZKP Creation Function One of the argument of the ZKP creation function is the witness. Therefore, if you want to spend a note, the wallet needs to compute its witness at a given height.\nWallets are not obligated to provide the latest witnesses. But since the height is public information, if a wallet does not update the witnesses it would be possible to gain some knowledge by looking at the witness heights of a transaction.\nNote If a wallet does not update the note witnesses, one can check the height when a note is spent and deduce when it was received.\nNullifiers In Bitcoin, to spend a UTXO, a wallet simply has to refer to it and attach a digital signature proving it knows the secret key.\nIn Zcash, UTXO are encrypted. But that’s not enough. Spending a UTXO must also be hidden. If Zcash transactions referred to UTXO like Bitcoin does, one could know when the UTXO was created. Therefore even if it would be impossible to know the values and addresses of the notes, it would be possible to link notes with transactions.\nTo avoid this, Zcash transactions do not directly refer to UTXO but they refer to a nullifier instead.\nNullifiers are unique values associated with a note. Only the receiver of the note can create the nullifier and it’s impossible to make a nullifier for a note that does not exist. The exact mechanism used to achieve this is beyond the scope of this document.\nNote Each UTXO has a unique nullifier. Nullifiers cannot be faked: Anyone can verify that a nullifier is associated with a real UTXO.\nScan Outputs In conclusion, let’s review what a scan must do:\nIt must scan each transaction and try to decrypt its outputs. Successful decryptions generate “received notes” (fresh UTXO). For each received note, the wallet can calculate its nullifier. Spent notes are detected when their nullifier is used in a later transaction. For each UTXO, the wallet maintains a witness that it should keep updating. ","description":"","tags":null,"title":"Scan / Sync","uri":"/light_wallet/scan/"},{"content":"Example using Java Checkout the integrations/java directory for an example of how to use JAVA with Warp Sync to create a new account and query the seed phrase and address.\nMain class package app.ywallet; import java.sql.*; /** */ public class App { static { System.loadLibrary(\"java_warp\"); } public static void main( String[] args ) throws Exception { Class.forName(\"org.sqlite.JDBC\"); final App app = new App(); // Create a new account final int id = app.newAccount(); // Connect to the database via JDBC Connection conn = DriverManager.getConnection(\"jdbc:sqlite:zec.db\"); // Query the seed and address of the account by id String query = \"SELECT seed, address FROM accounts WHERE id_account = ?\"; PreparedStatement statement = conn.prepareStatement(query); statement.setInt(1, id); ResultSet rs = statement.executeQuery(); while (rs.next()) { String seed = rs.getString(1); String address = rs.getString(2); System.out.println(\"seed phrase: \" + seed + \", address: \" + address); } } private native int newAccount(); } JNI Wrapper The JNI wrapper calls new_account and returns the new account id. In a more realistic case, the wallet would be initialized only once and the account name would be passed in.\nJNIEXPORT jint JNICALL Java_app_ywallet_App_newAccount (JNIEnv *, jobject) { init_wallet((char *)\".\"); CResult_u32 result = new_account(0, (char *)\"test\", (char*)\"\", 0); return result.value; } Makefile The Makefile builds the JNI library that should be copied into the JAVA lib path.\nlibjava_warp.so: app_ywallet_App.o: app_ywallet_App.cpp g++ -c -fPIC -I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux app_ywallet_App.cpp libjava_warp.so: app_ywallet_App.o g++ -shared -fPIC -o libjava_warp.so app_ywallet_App.o -L/usr/lib -lwarp_api_ffi ","description":"","tags":null,"title":"Java","uri":"/developer/java/"},{"content":"Reorganizations happen when several miners submit different blocks at the same height.\nIt is a rare occurence but it happens.\nFor example, if you have the following situation:\nMiner A submits block 1001 after block 1000 Miner B submits a different block 1001 Miner C submits a block 1002 based on miner B’s block 1001 Now we have two chains that deviate at block 1000:\none built from Miner A’s block 1001 the other from Miner B’s block 1001 and Miner C’s 1002 Since nodes cannot determine a-priori which chains will get longer after seeing block 1001, some of them first follow Miner A while others follow Miner B.\nBut when Miner C produces block 1002, Miner B’s chain is now longer than Miner A’s.\nInfo Nodes have to follow the longest chain.\nWhen nodes that were following Miner A’s chain see the blocks from Miner B and C’s chain, they must switch over.\nThis is called a block reorganization. Note that the nodes that were already following Miner B and C do not switch. Therefore, a block reorganization is a local event.\nAfter effects When a node has to perform a block reorganization, it must undo the effects of the blocks that are no longer valid. In this case, Miner A’s block 1001. Every transaction from that block must be undone:\nnotes that were spent are returned new notes that were created are destroyed In other words, the node should return to the point before Miner A’s block 1001 and process Miner B’s block 1001 instead. Then it should continue with Miner C’s block 1002.\nFailure to handle reorganization leads to incorrect state, so it’s paramount that a wallet can undo a previously applied block.\nHowever, in normal situation reorganizations are short lived. It is very unlikely to have a reorganization longer than a few blocks.\nWe assume that reorganizations are always shorter than 100 blocks.\n","description":"","tags":null,"title":"Reorganization","uri":"/light_wallet/reorg/"},{"content":"Documentation The API has its own documentation pages.\nExample using Rust Checkout the integrations/rust directory for an example of how to use JAVA with Warp Sync to create a new account and query the seed phrase and address.\nuse warp_api_ffi::api::account::{get_backup, new_account}; use warp_api_ffi::api::sync::coin_sync; use warp_api_ffi::{CoinConfig, init_coin, set_coin_lwd_url}; use lazy_static::lazy_static; use std::sync::Mutex; lazy_static! { static ref CANCEL: Mutex\u003cbool\u003e = Mutex::new(false); } const FVK: \u0026str = \"zxviews1q0duytgcqqqqpqre26wkl45gvwwwd706xw608hucmvfalr759ejwf7qshjf5r9aa7323zulvz6plhttp5mltqcgs9t039cx2d09mgq05ts63n8u35hyv6h9nc9ctqqtue2u7cer2mqegunuulq2luhq3ywjcz35yyljewa4mgkgjzyfwh6fr6jd0dzd44ghk0nxdv2hnv4j5nxfwv24rwdmgllhe0p8568sgqt9ckt02v2kxf5ahtql6s0ltjpkckw8gtymxtxuu9gcr0swvz\"; #[tokio::main] async fn main() { env_logger::init(); // Initialize the library for Zcash (coin = 0) init_coin(0, \"./zec.db\").unwrap(); set_coin_lwd_url(0, \"https://lwdv3.zecwallet.co:443\"); // ZecWallet Lightwalletd URL // Create a new account with the ZEC pages viewing key let id_account = new_account(0, \"test_account\", Some(FVK.to_string()), None).unwrap(); // Synchronize coin_sync(0 /* zcash */, true /* retrieve tx details */, 0 /* sync to tip */, 100 /* spam filter threshold */, |p| { log::info!(\"Progress: {}\", p.height); }, \u0026CANCEL).await.unwrap(); // Grab the database accessor let cc = \u0026CoinConfig::get(0 /* zcash */); let db = cc.db.as_ref().unwrap().clone(); let db = db.lock().unwrap(); // Query the account balance let balance = db.get_balance(id_account).unwrap(); println!(\"Balance = {}\", balance) } ","description":"","tags":null,"title":"Rust","uri":"/developer/rust/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/"}]