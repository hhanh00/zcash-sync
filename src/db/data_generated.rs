// automatically generated by the FlatBuffers compiler, do not modify

// @generated

extern crate flatbuffers;

#[allow(unused_imports, dead_code)]
pub mod fb {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum AccountOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Account<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Account<'a> {
        type Inner = Account<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Account<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_BALANCE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Account { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AccountArgs<'args>,
        ) -> flatbuffers::WIPOffset<Account<'bldr>> {
            let mut builder = AccountBuilder::new(_fbb);
            builder.add_balance(args.balance);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_id(args.id);
            builder.add_key_type(args.key_type);
            builder.finish()
        }

        pub fn unpack(&self) -> AccountT {
            let id = self.id();
            let name = self.name().map(|x| x.to_string());
            let key_type = self.key_type();
            let balance = self.balance();
            AccountT {
                id,
                name,
                key_type,
                balance,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Account::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Account::VT_NAME, None)
            }
        }
        #[inline]
        pub fn key_type(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(Account::VT_KEY_TYPE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn balance(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Account::VT_BALANCE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Account<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<u8>("key_type", Self::VT_KEY_TYPE, false)?
                .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AccountArgs<'a> {
        pub id: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub key_type: u8,
        pub balance: u64,
    }
    impl<'a> Default for AccountArgs<'a> {
        #[inline]
        fn default() -> Self {
            AccountArgs {
                id: 0,
                name: None,
                key_type: 0,
                balance: 0,
            }
        }
    }

    pub struct AccountBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AccountBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(Account::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Account::VT_NAME, name);
        }
        #[inline]
        pub fn add_key_type(&mut self, key_type: u8) {
            self.fbb_.push_slot::<u8>(Account::VT_KEY_TYPE, key_type, 0);
        }
        #[inline]
        pub fn add_balance(&mut self, balance: u64) {
            self.fbb_.push_slot::<u64>(Account::VT_BALANCE, balance, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AccountBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AccountBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Account<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Account<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Account");
            ds.field("id", &self.id());
            ds.field("name", &self.name());
            ds.field("key_type", &self.key_type());
            ds.field("balance", &self.balance());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AccountT {
        pub id: u32,
        pub name: Option<String>,
        pub key_type: u8,
        pub balance: u64,
    }
    impl Default for AccountT {
        fn default() -> Self {
            Self {
                id: 0,
                name: None,
                key_type: 0,
                balance: 0,
            }
        }
    }
    impl AccountT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Account<'b>> {
            let id = self.id;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let key_type = self.key_type;
            let balance = self.balance;
            Account::create(
                _fbb,
                &AccountArgs {
                    id,
                    name,
                    key_type,
                    balance,
                },
            )
        }
    }
    pub enum AccountVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AccountVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AccountVec<'a> {
        type Inner = AccountVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AccountVec<'a> {
        pub const VT_ACCOUNTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AccountVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AccountVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<AccountVec<'bldr>> {
            let mut builder = AccountVecBuilder::new(_fbb);
            if let Some(x) = args.accounts {
                builder.add_accounts(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AccountVecT {
            let accounts = self
                .accounts()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            AccountVecT { accounts }
        }

        #[inline]
        pub fn accounts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account>>,
                >>(AccountVec::VT_ACCOUNTS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AccountVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Account>>,
                >>("accounts", Self::VT_ACCOUNTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AccountVecArgs<'a> {
        pub accounts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Account<'a>>>,
            >,
        >,
    }
    impl<'a> Default for AccountVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            AccountVecArgs { accounts: None }
        }
    }

    pub struct AccountVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AccountVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_accounts(
            &mut self,
            accounts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Account<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AccountVec::VT_ACCOUNTS, accounts);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AccountVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AccountVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AccountVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AccountVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AccountVec");
            ds.field("accounts", &self.accounts());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AccountVecT {
        pub accounts: Option<Vec<AccountT>>,
    }
    impl Default for AccountVecT {
        fn default() -> Self {
            Self { accounts: None }
        }
    }
    impl AccountVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<AccountVec<'b>> {
            let accounts = self.accounts.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            AccountVec::create(_fbb, &AccountVecArgs { accounts })
        }
    }
    pub enum BalanceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Balance<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Balance<'a> {
        type Inner = Balance<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Balance<'a> {
        pub const VT_SHIELDED: flatbuffers::VOffsetT = 4;
        pub const VT_UNCONFIRMED_SPENT: flatbuffers::VOffsetT = 6;
        pub const VT_BALANCE: flatbuffers::VOffsetT = 8;
        pub const VT_UNDER_CONFIRMED: flatbuffers::VOffsetT = 10;
        pub const VT_EXCLUDED: flatbuffers::VOffsetT = 12;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 14;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Balance { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BalanceArgs,
        ) -> flatbuffers::WIPOffset<Balance<'bldr>> {
            let mut builder = BalanceBuilder::new(_fbb);
            builder.add_orchard(args.orchard);
            builder.add_sapling(args.sapling);
            builder.add_excluded(args.excluded);
            builder.add_under_confirmed(args.under_confirmed);
            builder.add_balance(args.balance);
            builder.add_unconfirmed_spent(args.unconfirmed_spent);
            builder.add_shielded(args.shielded);
            builder.finish()
        }

        pub fn unpack(&self) -> BalanceT {
            let shielded = self.shielded();
            let unconfirmed_spent = self.unconfirmed_spent();
            let balance = self.balance();
            let under_confirmed = self.under_confirmed();
            let excluded = self.excluded();
            let sapling = self.sapling();
            let orchard = self.orchard();
            BalanceT {
                shielded,
                unconfirmed_spent,
                balance,
                under_confirmed,
                excluded,
                sapling,
                orchard,
            }
        }

        #[inline]
        pub fn shielded(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_SHIELDED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn unconfirmed_spent(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Balance::VT_UNCONFIRMED_SPENT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn balance(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_BALANCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn under_confirmed(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Balance::VT_UNDER_CONFIRMED, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn excluded(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_EXCLUDED, Some(0)).unwrap() }
        }
        #[inline]
        pub fn sapling(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_SAPLING, Some(0)).unwrap() }
        }
        #[inline]
        pub fn orchard(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Balance::VT_ORCHARD, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Balance<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("shielded", Self::VT_SHIELDED, false)?
                .visit_field::<u64>("unconfirmed_spent", Self::VT_UNCONFIRMED_SPENT, false)?
                .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
                .visit_field::<u64>("under_confirmed", Self::VT_UNDER_CONFIRMED, false)?
                .visit_field::<u64>("excluded", Self::VT_EXCLUDED, false)?
                .visit_field::<u64>("sapling", Self::VT_SAPLING, false)?
                .visit_field::<u64>("orchard", Self::VT_ORCHARD, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BalanceArgs {
        pub shielded: u64,
        pub unconfirmed_spent: u64,
        pub balance: u64,
        pub under_confirmed: u64,
        pub excluded: u64,
        pub sapling: u64,
        pub orchard: u64,
    }
    impl<'a> Default for BalanceArgs {
        #[inline]
        fn default() -> Self {
            BalanceArgs {
                shielded: 0,
                unconfirmed_spent: 0,
                balance: 0,
                under_confirmed: 0,
                excluded: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }

    pub struct BalanceBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BalanceBuilder<'a, 'b> {
        #[inline]
        pub fn add_shielded(&mut self, shielded: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_SHIELDED, shielded, 0);
        }
        #[inline]
        pub fn add_unconfirmed_spent(&mut self, unconfirmed_spent: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_UNCONFIRMED_SPENT, unconfirmed_spent, 0);
        }
        #[inline]
        pub fn add_balance(&mut self, balance: u64) {
            self.fbb_.push_slot::<u64>(Balance::VT_BALANCE, balance, 0);
        }
        #[inline]
        pub fn add_under_confirmed(&mut self, under_confirmed: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_UNDER_CONFIRMED, under_confirmed, 0);
        }
        #[inline]
        pub fn add_excluded(&mut self, excluded: u64) {
            self.fbb_
                .push_slot::<u64>(Balance::VT_EXCLUDED, excluded, 0);
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: u64) {
            self.fbb_.push_slot::<u64>(Balance::VT_SAPLING, sapling, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: u64) {
            self.fbb_.push_slot::<u64>(Balance::VT_ORCHARD, orchard, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BalanceBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BalanceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Balance<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Balance<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Balance");
            ds.field("shielded", &self.shielded());
            ds.field("unconfirmed_spent", &self.unconfirmed_spent());
            ds.field("balance", &self.balance());
            ds.field("under_confirmed", &self.under_confirmed());
            ds.field("excluded", &self.excluded());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BalanceT {
        pub shielded: u64,
        pub unconfirmed_spent: u64,
        pub balance: u64,
        pub under_confirmed: u64,
        pub excluded: u64,
        pub sapling: u64,
        pub orchard: u64,
    }
    impl Default for BalanceT {
        fn default() -> Self {
            Self {
                shielded: 0,
                unconfirmed_spent: 0,
                balance: 0,
                under_confirmed: 0,
                excluded: 0,
                sapling: 0,
                orchard: 0,
            }
        }
    }
    impl BalanceT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Balance<'b>> {
            let shielded = self.shielded;
            let unconfirmed_spent = self.unconfirmed_spent;
            let balance = self.balance;
            let under_confirmed = self.under_confirmed;
            let excluded = self.excluded;
            let sapling = self.sapling;
            let orchard = self.orchard;
            Balance::create(
                _fbb,
                &BalanceArgs {
                    shielded,
                    unconfirmed_spent,
                    balance,
                    under_confirmed,
                    excluded,
                    sapling,
                    orchard,
                },
            )
        }
    }
    pub enum HeightOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Height<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Height<'a> {
        type Inner = Height<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Height<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Height { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args HeightArgs,
        ) -> flatbuffers::WIPOffset<Height<'bldr>> {
            let mut builder = HeightBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.finish()
        }

        pub fn unpack(&self) -> HeightT {
            let height = self.height();
            let timestamp = self.timestamp();
            HeightT { height, timestamp }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Height::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Height::VT_TIMESTAMP, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Height<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct HeightArgs {
        pub height: u32,
        pub timestamp: u32,
    }
    impl<'a> Default for HeightArgs {
        #[inline]
        fn default() -> Self {
            HeightArgs {
                height: 0,
                timestamp: 0,
            }
        }
    }

    pub struct HeightBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HeightBuilder<'a, 'b> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Height::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Height::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeightBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HeightBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Height<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Height<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Height");
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct HeightT {
        pub height: u32,
        pub timestamp: u32,
    }
    impl Default for HeightT {
        fn default() -> Self {
            Self {
                height: 0,
                timestamp: 0,
            }
        }
    }
    impl HeightT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Height<'b>> {
            let height = self.height;
            let timestamp = self.timestamp;
            Height::create(_fbb, &HeightArgs { height, timestamp })
        }
    }
    pub enum ShieldedNoteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedNote<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedNote<'a> {
        type Inner = ShieldedNote<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedNote<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 12;
        pub const VT_EXCLUDED: flatbuffers::VOffsetT = 14;
        pub const VT_SPENT: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedNote { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ShieldedNoteArgs,
        ) -> flatbuffers::WIPOffset<ShieldedNote<'bldr>> {
            let mut builder = ShieldedNoteBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.add_id(args.id);
            builder.add_spent(args.spent);
            builder.add_excluded(args.excluded);
            builder.add_orchard(args.orchard);
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedNoteT {
            let id = self.id();
            let height = self.height();
            let value = self.value();
            let timestamp = self.timestamp();
            let orchard = self.orchard();
            let excluded = self.excluded();
            let spent = self.spent();
            ShieldedNoteT {
                id,
                height,
                value,
                timestamp,
                orchard,
                excluded,
                spent,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(ShieldedNote::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedNote::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ShieldedNote::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedNote::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn orchard(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedNote::VT_ORCHARD, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn excluded(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedNote::VT_EXCLUDED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn spent(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ShieldedNote::VT_SPENT, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedNote<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<bool>("orchard", Self::VT_ORCHARD, false)?
                .visit_field::<bool>("excluded", Self::VT_EXCLUDED, false)?
                .visit_field::<bool>("spent", Self::VT_SPENT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedNoteArgs {
        pub id: u32,
        pub height: u32,
        pub value: u64,
        pub timestamp: u32,
        pub orchard: bool,
        pub excluded: bool,
        pub spent: bool,
    }
    impl<'a> Default for ShieldedNoteArgs {
        #[inline]
        fn default() -> Self {
            ShieldedNoteArgs {
                id: 0,
                height: 0,
                value: 0,
                timestamp: 0,
                orchard: false,
                excluded: false,
                spent: false,
            }
        }
    }

    pub struct ShieldedNoteBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ShieldedNoteBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(ShieldedNote::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedNote::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(ShieldedNote::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedNote::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedNote::VT_ORCHARD, orchard, false);
        }
        #[inline]
        pub fn add_excluded(&mut self, excluded: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedNote::VT_EXCLUDED, excluded, false);
        }
        #[inline]
        pub fn add_spent(&mut self, spent: bool) {
            self.fbb_
                .push_slot::<bool>(ShieldedNote::VT_SPENT, spent, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ShieldedNoteBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ShieldedNoteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedNote<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedNote<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedNote");
            ds.field("id", &self.id());
            ds.field("height", &self.height());
            ds.field("value", &self.value());
            ds.field("timestamp", &self.timestamp());
            ds.field("orchard", &self.orchard());
            ds.field("excluded", &self.excluded());
            ds.field("spent", &self.spent());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShieldedNoteT {
        pub id: u32,
        pub height: u32,
        pub value: u64,
        pub timestamp: u32,
        pub orchard: bool,
        pub excluded: bool,
        pub spent: bool,
    }
    impl Default for ShieldedNoteT {
        fn default() -> Self {
            Self {
                id: 0,
                height: 0,
                value: 0,
                timestamp: 0,
                orchard: false,
                excluded: false,
                spent: false,
            }
        }
    }
    impl ShieldedNoteT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ShieldedNote<'b>> {
            let id = self.id;
            let height = self.height;
            let value = self.value;
            let timestamp = self.timestamp;
            let orchard = self.orchard;
            let excluded = self.excluded;
            let spent = self.spent;
            ShieldedNote::create(
                _fbb,
                &ShieldedNoteArgs {
                    id,
                    height,
                    value,
                    timestamp,
                    orchard,
                    excluded,
                    spent,
                },
            )
        }
    }
    pub enum ShieldedNoteVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedNoteVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedNoteVec<'a> {
        type Inner = ShieldedNoteVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedNoteVec<'a> {
        pub const VT_NOTES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedNoteVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ShieldedNoteVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<ShieldedNoteVec<'bldr>> {
            let mut builder = ShieldedNoteVecBuilder::new(_fbb);
            if let Some(x) = args.notes {
                builder.add_notes(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedNoteVecT {
            let notes = self.notes().map(|x| x.iter().map(|t| t.unpack()).collect());
            ShieldedNoteVecT { notes }
        }

        #[inline]
        pub fn notes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote>>,
                >>(ShieldedNoteVec::VT_NOTES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedNoteVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ShieldedNote>>,
                >>("notes", Self::VT_NOTES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedNoteVecArgs<'a> {
        pub notes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedNote<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ShieldedNoteVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            ShieldedNoteVecArgs { notes: None }
        }
    }

    pub struct ShieldedNoteVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ShieldedNoteVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_notes(
            &mut self,
            notes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ShieldedNote<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedNoteVec::VT_NOTES, notes);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ShieldedNoteVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ShieldedNoteVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedNoteVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedNoteVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedNoteVec");
            ds.field("notes", &self.notes());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShieldedNoteVecT {
        pub notes: Option<Vec<ShieldedNoteT>>,
    }
    impl Default for ShieldedNoteVecT {
        fn default() -> Self {
            Self { notes: None }
        }
    }
    impl ShieldedNoteVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ShieldedNoteVec<'b>> {
            let notes = self.notes.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            ShieldedNoteVec::create(_fbb, &ShieldedNoteVecArgs { notes })
        }
    }
    pub enum ShieldedTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedTx<'a> {
        type Inner = ShieldedTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedTx<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TX_ID: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_SHORT_TX_ID: flatbuffers::VOffsetT = 10;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
        pub const VT_NAME: flatbuffers::VOffsetT = 14;
        pub const VT_VALUE: flatbuffers::VOffsetT = 16;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 18;
        pub const VT_MEMO: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ShieldedTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<ShieldedTx<'bldr>> {
            let mut builder = ShieldedTxBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.short_tx_id {
                builder.add_short_tx_id(x);
            }
            builder.add_height(args.height);
            if let Some(x) = args.tx_id {
                builder.add_tx_id(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedTxT {
            let id = self.id();
            let tx_id = self.tx_id().map(|x| x.to_string());
            let height = self.height();
            let short_tx_id = self.short_tx_id().map(|x| x.to_string());
            let timestamp = self.timestamp();
            let name = self.name().map(|x| x.to_string());
            let value = self.value();
            let address = self.address().map(|x| x.to_string());
            let memo = self.memo().map(|x| x.to_string());
            ShieldedTxT {
                id,
                tx_id,
                height,
                short_tx_id,
                timestamp,
                name,
                value,
                address,
                memo,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(ShieldedTx::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn tx_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_TX_ID, None)
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedTx::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn short_tx_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_SHORT_TX_ID, None)
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ShieldedTx::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_NAME, None)
            }
        }
        #[inline]
        pub fn value(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(ShieldedTx::VT_VALUE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ShieldedTx::VT_MEMO, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tx_id", Self::VT_TX_ID, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "short_tx_id",
                    Self::VT_SHORT_TX_ID,
                    false,
                )?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<i64>("value", Self::VT_VALUE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedTxArgs<'a> {
        pub id: u32,
        pub tx_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub height: u32,
        pub short_tx_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub timestamp: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: i64,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ShieldedTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            ShieldedTxArgs {
                id: 0,
                tx_id: None,
                height: 0,
                short_tx_id: None,
                timestamp: 0,
                name: None,
                value: 0,
                address: None,
                memo: None,
            }
        }
    }

    pub struct ShieldedTxBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ShieldedTxBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(ShieldedTx::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_tx_id(&mut self, tx_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTx::VT_TX_ID, tx_id);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(ShieldedTx::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_short_tx_id(&mut self, short_tx_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ShieldedTx::VT_SHORT_TX_ID,
                short_tx_id,
            );
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(ShieldedTx::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTx::VT_NAME, name);
        }
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_.push_slot::<i64>(ShieldedTx::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTx::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTx::VT_MEMO, memo);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShieldedTxBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ShieldedTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedTx");
            ds.field("id", &self.id());
            ds.field("tx_id", &self.tx_id());
            ds.field("height", &self.height());
            ds.field("short_tx_id", &self.short_tx_id());
            ds.field("timestamp", &self.timestamp());
            ds.field("name", &self.name());
            ds.field("value", &self.value());
            ds.field("address", &self.address());
            ds.field("memo", &self.memo());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShieldedTxT {
        pub id: u32,
        pub tx_id: Option<String>,
        pub height: u32,
        pub short_tx_id: Option<String>,
        pub timestamp: u32,
        pub name: Option<String>,
        pub value: i64,
        pub address: Option<String>,
        pub memo: Option<String>,
    }
    impl Default for ShieldedTxT {
        fn default() -> Self {
            Self {
                id: 0,
                tx_id: None,
                height: 0,
                short_tx_id: None,
                timestamp: 0,
                name: None,
                value: 0,
                address: None,
                memo: None,
            }
        }
    }
    impl ShieldedTxT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ShieldedTx<'b>> {
            let id = self.id;
            let tx_id = self.tx_id.as_ref().map(|x| _fbb.create_string(x));
            let height = self.height;
            let short_tx_id = self.short_tx_id.as_ref().map(|x| _fbb.create_string(x));
            let timestamp = self.timestamp;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let value = self.value;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            ShieldedTx::create(
                _fbb,
                &ShieldedTxArgs {
                    id,
                    tx_id,
                    height,
                    short_tx_id,
                    timestamp,
                    name,
                    value,
                    address,
                    memo,
                },
            )
        }
    }
    pub enum ShieldedTxVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShieldedTxVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShieldedTxVec<'a> {
        type Inner = ShieldedTxVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShieldedTxVec<'a> {
        pub const VT_TXS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShieldedTxVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ShieldedTxVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<ShieldedTxVec<'bldr>> {
            let mut builder = ShieldedTxVecBuilder::new(_fbb);
            if let Some(x) = args.txs {
                builder.add_txs(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ShieldedTxVecT {
            let txs = self.txs().map(|x| x.iter().map(|t| t.unpack()).collect());
            ShieldedTxVecT { txs }
        }

        #[inline]
        pub fn txs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedTx<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedTx>>,
                >>(ShieldedTxVec::VT_TXS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ShieldedTxVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ShieldedTx>>,
                >>("txs", Self::VT_TXS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShieldedTxVecArgs<'a> {
        pub txs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ShieldedTx<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ShieldedTxVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            ShieldedTxVecArgs { txs: None }
        }
    }

    pub struct ShieldedTxVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ShieldedTxVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_txs(
            &mut self,
            txs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ShieldedTx<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ShieldedTxVec::VT_TXS, txs);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ShieldedTxVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ShieldedTxVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShieldedTxVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShieldedTxVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShieldedTxVec");
            ds.field("txs", &self.txs());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ShieldedTxVecT {
        pub txs: Option<Vec<ShieldedTxT>>,
    }
    impl Default for ShieldedTxVecT {
        fn default() -> Self {
            Self { txs: None }
        }
    }
    impl ShieldedTxVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ShieldedTxVec<'b>> {
            let txs = self.txs.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            ShieldedTxVec::create(_fbb, &ShieldedTxVecArgs { txs })
        }
    }
    pub enum PlainTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PlainTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PlainTx<'a> {
        type Inner = PlainTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PlainTx<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TX_ID: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
        pub const VT_VALUE: flatbuffers::VOffsetT = 12;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PlainTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlainTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<PlainTx<'bldr>> {
            let mut builder = PlainTxBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            if let Some(x) = args.tx_id {
                builder.add_tx_id(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> PlainTxT {
            let id = self.id();
            let tx_id = self.tx_id().map(|x| x.to_string());
            let height = self.height();
            let timestamp = self.timestamp();
            let value = self.value();
            let address = self.address().map(|x| x.to_string());
            PlainTxT {
                id,
                tx_id,
                height,
                timestamp,
                value,
                address,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PlainTx::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn tx_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PlainTx::VT_TX_ID, None)
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PlainTx::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(PlainTx::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i64>(PlainTx::VT_VALUE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PlainTx::VT_ADDRESS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for PlainTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tx_id", Self::VT_TX_ID, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<i64>("value", Self::VT_VALUE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct PlainTxArgs<'a> {
        pub id: u32,
        pub tx_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub height: u32,
        pub timestamp: u32,
        pub value: i64,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for PlainTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlainTxArgs {
                id: 0,
                tx_id: None,
                height: 0,
                timestamp: 0,
                value: 0,
                address: None,
            }
        }
    }

    pub struct PlainTxBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlainTxBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(PlainTx::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_tx_id(&mut self, tx_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PlainTx::VT_TX_ID, tx_id);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(PlainTx::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(PlainTx::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: i64) {
            self.fbb_.push_slot::<i64>(PlainTx::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PlainTx::VT_ADDRESS, address);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlainTxBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlainTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PlainTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PlainTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PlainTx");
            ds.field("id", &self.id());
            ds.field("tx_id", &self.tx_id());
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.field("value", &self.value());
            ds.field("address", &self.address());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PlainTxT {
        pub id: u32,
        pub tx_id: Option<String>,
        pub height: u32,
        pub timestamp: u32,
        pub value: i64,
        pub address: Option<String>,
    }
    impl Default for PlainTxT {
        fn default() -> Self {
            Self {
                id: 0,
                tx_id: None,
                height: 0,
                timestamp: 0,
                value: 0,
                address: None,
            }
        }
    }
    impl PlainTxT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<PlainTx<'b>> {
            let id = self.id;
            let tx_id = self.tx_id.as_ref().map(|x| _fbb.create_string(x));
            let height = self.height;
            let timestamp = self.timestamp;
            let value = self.value;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            PlainTx::create(
                _fbb,
                &PlainTxArgs {
                    id,
                    tx_id,
                    height,
                    timestamp,
                    value,
                    address,
                },
            )
        }
    }
    pub enum PlainTxVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PlainTxVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PlainTxVec<'a> {
        type Inner = PlainTxVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PlainTxVec<'a> {
        pub const VT_TXS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PlainTxVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlainTxVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<PlainTxVec<'bldr>> {
            let mut builder = PlainTxVecBuilder::new(_fbb);
            if let Some(x) = args.txs {
                builder.add_txs(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> PlainTxVecT {
            let txs = self.txs().map(|x| x.iter().map(|t| t.unpack()).collect());
            PlainTxVecT { txs }
        }

        #[inline]
        pub fn txs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlainTx<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlainTx>>,
                >>(PlainTxVec::VT_TXS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for PlainTxVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlainTx>>,
                >>("txs", Self::VT_TXS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PlainTxVecArgs<'a> {
        pub txs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlainTx<'a>>>,
            >,
        >,
    }
    impl<'a> Default for PlainTxVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlainTxVecArgs { txs: None }
        }
    }

    pub struct PlainTxVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlainTxVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_txs(
            &mut self,
            txs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlainTx<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PlainTxVec::VT_TXS, txs);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlainTxVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlainTxVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PlainTxVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PlainTxVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PlainTxVec");
            ds.field("txs", &self.txs());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PlainTxVecT {
        pub txs: Option<Vec<PlainTxT>>,
    }
    impl Default for PlainTxVecT {
        fn default() -> Self {
            Self { txs: None }
        }
    }
    impl PlainTxVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<PlainTxVec<'b>> {
            let txs = self.txs.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            PlainTxVec::create(_fbb, &PlainTxVecArgs { txs })
        }
    }
    pub enum PlainNoteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PlainNote<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PlainNote<'a> {
        type Inner = PlainNote<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PlainNote<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TX_ID: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
        pub const VT_VOUT: flatbuffers::VOffsetT = 12;
        pub const VT_VALUE: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PlainNote { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlainNoteArgs<'args>,
        ) -> flatbuffers::WIPOffset<PlainNote<'bldr>> {
            let mut builder = PlainNoteBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.add_vout(args.vout);
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            if let Some(x) = args.tx_id {
                builder.add_tx_id(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> PlainNoteT {
            let id = self.id();
            let tx_id = self.tx_id().map(|x| x.to_string());
            let height = self.height();
            let timestamp = self.timestamp();
            let vout = self.vout();
            let value = self.value();
            PlainNoteT {
                id,
                tx_id,
                height,
                timestamp,
                vout,
                value,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PlainNote::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn tx_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PlainNote::VT_TX_ID, None)
            }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PlainNote::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(PlainNote::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn vout(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PlainNote::VT_VOUT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(PlainNote::VT_VALUE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for PlainNote<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tx_id", Self::VT_TX_ID, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<u32>("vout", Self::VT_VOUT, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PlainNoteArgs<'a> {
        pub id: u32,
        pub tx_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub height: u32,
        pub timestamp: u32,
        pub vout: u32,
        pub value: u64,
    }
    impl<'a> Default for PlainNoteArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlainNoteArgs {
                id: 0,
                tx_id: None,
                height: 0,
                timestamp: 0,
                vout: 0,
                value: 0,
            }
        }
    }

    pub struct PlainNoteBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlainNoteBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(PlainNote::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_tx_id(&mut self, tx_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PlainNote::VT_TX_ID, tx_id);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(PlainNote::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(PlainNote::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_vout(&mut self, vout: u32) {
            self.fbb_.push_slot::<u32>(PlainNote::VT_VOUT, vout, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(PlainNote::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlainNoteBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlainNoteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PlainNote<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PlainNote<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PlainNote");
            ds.field("id", &self.id());
            ds.field("tx_id", &self.tx_id());
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.field("vout", &self.vout());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PlainNoteT {
        pub id: u32,
        pub tx_id: Option<String>,
        pub height: u32,
        pub timestamp: u32,
        pub vout: u32,
        pub value: u64,
    }
    impl Default for PlainNoteT {
        fn default() -> Self {
            Self {
                id: 0,
                tx_id: None,
                height: 0,
                timestamp: 0,
                vout: 0,
                value: 0,
            }
        }
    }
    impl PlainNoteT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<PlainNote<'b>> {
            let id = self.id;
            let tx_id = self.tx_id.as_ref().map(|x| _fbb.create_string(x));
            let height = self.height;
            let timestamp = self.timestamp;
            let vout = self.vout;
            let value = self.value;
            PlainNote::create(
                _fbb,
                &PlainNoteArgs {
                    id,
                    tx_id,
                    height,
                    timestamp,
                    vout,
                    value,
                },
            )
        }
    }
    pub enum PlainNoteVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PlainNoteVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PlainNoteVec<'a> {
        type Inner = PlainNoteVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PlainNoteVec<'a> {
        pub const VT_NOTES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PlainNoteVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlainNoteVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<PlainNoteVec<'bldr>> {
            let mut builder = PlainNoteVecBuilder::new(_fbb);
            if let Some(x) = args.notes {
                builder.add_notes(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> PlainNoteVecT {
            let notes = self.notes().map(|x| x.iter().map(|t| t.unpack()).collect());
            PlainNoteVecT { notes }
        }

        #[inline]
        pub fn notes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlainNote<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlainNote>>,
                >>(PlainNoteVec::VT_NOTES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for PlainNoteVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlainNote>>,
                >>("notes", Self::VT_NOTES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PlainNoteVecArgs<'a> {
        pub notes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlainNote<'a>>>,
            >,
        >,
    }
    impl<'a> Default for PlainNoteVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlainNoteVecArgs { notes: None }
        }
    }

    pub struct PlainNoteVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlainNoteVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_notes(
            &mut self,
            notes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlainNote<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PlainNoteVec::VT_NOTES, notes);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PlainNoteVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlainNoteVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PlainNoteVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PlainNoteVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PlainNoteVec");
            ds.field("notes", &self.notes());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PlainNoteVecT {
        pub notes: Option<Vec<PlainNoteT>>,
    }
    impl Default for PlainNoteVecT {
        fn default() -> Self {
            Self { notes: None }
        }
    }
    impl PlainNoteVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<PlainNoteVec<'b>> {
            let notes = self.notes.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            PlainNoteVec::create(_fbb, &PlainNoteVecArgs { notes })
        }
    }
    pub enum BTCInputOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BTCInput<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BTCInput<'a> {
        type Inner = BTCInput<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BTCInput<'a> {
        pub const VT_TX_ID: flatbuffers::VOffsetT = 4;
        pub const VT_VOUT: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BTCInput { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BTCInputArgs<'args>,
        ) -> flatbuffers::WIPOffset<BTCInput<'bldr>> {
            let mut builder = BTCInputBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.add_vout(args.vout);
            if let Some(x) = args.tx_id {
                builder.add_tx_id(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> BTCInputT {
            let tx_id = self.tx_id().map(|x| x.to_string());
            let vout = self.vout();
            let value = self.value();
            BTCInputT { tx_id, vout, value }
        }

        #[inline]
        pub fn tx_id(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(BTCInput::VT_TX_ID, None)
            }
        }
        #[inline]
        pub fn vout(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(BTCInput::VT_VOUT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(BTCInput::VT_VALUE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for BTCInput<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tx_id", Self::VT_TX_ID, false)?
                .visit_field::<u32>("vout", Self::VT_VOUT, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BTCInputArgs<'a> {
        pub tx_id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub vout: u32,
        pub value: u64,
    }
    impl<'a> Default for BTCInputArgs<'a> {
        #[inline]
        fn default() -> Self {
            BTCInputArgs {
                tx_id: None,
                vout: 0,
                value: 0,
            }
        }
    }

    pub struct BTCInputBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BTCInputBuilder<'a, 'b> {
        #[inline]
        pub fn add_tx_id(&mut self, tx_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BTCInput::VT_TX_ID, tx_id);
        }
        #[inline]
        pub fn add_vout(&mut self, vout: u32) {
            self.fbb_.push_slot::<u32>(BTCInput::VT_VOUT, vout, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(BTCInput::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BTCInputBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BTCInputBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BTCInput<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BTCInput<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BTCInput");
            ds.field("tx_id", &self.tx_id());
            ds.field("vout", &self.vout());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BTCInputT {
        pub tx_id: Option<String>,
        pub vout: u32,
        pub value: u64,
    }
    impl Default for BTCInputT {
        fn default() -> Self {
            Self {
                tx_id: None,
                vout: 0,
                value: 0,
            }
        }
    }
    impl BTCInputT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<BTCInput<'b>> {
            let tx_id = self.tx_id.as_ref().map(|x| _fbb.create_string(x));
            let vout = self.vout;
            let value = self.value;
            BTCInput::create(_fbb, &BTCInputArgs { tx_id, vout, value })
        }
    }
    pub enum BTCOutputOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BTCOutput<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BTCOutput<'a> {
        type Inner = BTCOutput<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BTCOutput<'a> {
        pub const VT_SCRIPT_PUBKEY: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BTCOutput { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BTCOutputArgs<'args>,
        ) -> flatbuffers::WIPOffset<BTCOutput<'bldr>> {
            let mut builder = BTCOutputBuilder::new(_fbb);
            builder.add_value(args.value);
            if let Some(x) = args.script_pubkey {
                builder.add_script_pubkey(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> BTCOutputT {
            let script_pubkey = self.script_pubkey().map(|x| x.to_string());
            let value = self.value();
            BTCOutputT {
                script_pubkey,
                value,
            }
        }

        #[inline]
        pub fn script_pubkey(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(BTCOutput::VT_SCRIPT_PUBKEY, None)
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(BTCOutput::VT_VALUE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for BTCOutput<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "script_pubkey",
                    Self::VT_SCRIPT_PUBKEY,
                    false,
                )?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BTCOutputArgs<'a> {
        pub script_pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: u64,
    }
    impl<'a> Default for BTCOutputArgs<'a> {
        #[inline]
        fn default() -> Self {
            BTCOutputArgs {
                script_pubkey: None,
                value: 0,
            }
        }
    }

    pub struct BTCOutputBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BTCOutputBuilder<'a, 'b> {
        #[inline]
        pub fn add_script_pubkey(&mut self, script_pubkey: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BTCOutput::VT_SCRIPT_PUBKEY,
                script_pubkey,
            );
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(BTCOutput::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BTCOutputBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BTCOutputBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BTCOutput<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BTCOutput<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BTCOutput");
            ds.field("script_pubkey", &self.script_pubkey());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BTCOutputT {
        pub script_pubkey: Option<String>,
        pub value: u64,
    }
    impl Default for BTCOutputT {
        fn default() -> Self {
            Self {
                script_pubkey: None,
                value: 0,
            }
        }
    }
    impl BTCOutputT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<BTCOutput<'b>> {
            let script_pubkey = self.script_pubkey.as_ref().map(|x| _fbb.create_string(x));
            let value = self.value;
            BTCOutput::create(
                _fbb,
                &BTCOutputArgs {
                    script_pubkey,
                    value,
                },
            )
        }
    }
    pub enum BTCTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BTCTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BTCTx<'a> {
        type Inner = BTCTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BTCTx<'a> {
        pub const VT_TXINS: flatbuffers::VOffsetT = 4;
        pub const VT_TXOUTS: flatbuffers::VOffsetT = 6;
        pub const VT_FEE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BTCTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BTCTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<BTCTx<'bldr>> {
            let mut builder = BTCTxBuilder::new(_fbb);
            builder.add_fee(args.fee);
            if let Some(x) = args.txouts {
                builder.add_txouts(x);
            }
            if let Some(x) = args.txins {
                builder.add_txins(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> BTCTxT {
            let txins = self.txins().map(|x| x.iter().map(|t| t.unpack()).collect());
            let txouts = self
                .txouts()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let fee = self.fee();
            BTCTxT { txins, txouts, fee }
        }

        #[inline]
        pub fn txins(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BTCInput<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BTCInput>>,
                >>(BTCTx::VT_TXINS, None)
            }
        }
        #[inline]
        pub fn txouts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BTCOutput<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BTCOutput>>,
                >>(BTCTx::VT_TXOUTS, None)
            }
        }
        #[inline]
        pub fn fee(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(BTCTx::VT_FEE, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for BTCTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BTCInput>>,
                >>("txins", Self::VT_TXINS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BTCOutput>>,
                >>("txouts", Self::VT_TXOUTS, false)?
                .visit_field::<u64>("fee", Self::VT_FEE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BTCTxArgs<'a> {
        pub txins: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BTCInput<'a>>>,
            >,
        >,
        pub txouts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BTCOutput<'a>>>,
            >,
        >,
        pub fee: u64,
    }
    impl<'a> Default for BTCTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            BTCTxArgs {
                txins: None,
                txouts: None,
                fee: 0,
            }
        }
    }

    pub struct BTCTxBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BTCTxBuilder<'a, 'b> {
        #[inline]
        pub fn add_txins(
            &mut self,
            txins: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BTCInput<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BTCTx::VT_TXINS, txins);
        }
        #[inline]
        pub fn add_txouts(
            &mut self,
            txouts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BTCOutput<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BTCTx::VT_TXOUTS, txouts);
        }
        #[inline]
        pub fn add_fee(&mut self, fee: u64) {
            self.fbb_.push_slot::<u64>(BTCTx::VT_FEE, fee, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BTCTxBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BTCTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BTCTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BTCTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BTCTx");
            ds.field("txins", &self.txins());
            ds.field("txouts", &self.txouts());
            ds.field("fee", &self.fee());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BTCTxT {
        pub txins: Option<Vec<BTCInputT>>,
        pub txouts: Option<Vec<BTCOutputT>>,
        pub fee: u64,
    }
    impl Default for BTCTxT {
        fn default() -> Self {
            Self {
                txins: None,
                txouts: None,
                fee: 0,
            }
        }
    }
    impl BTCTxT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<BTCTx<'b>> {
            let txins = self.txins.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let txouts = self.txouts.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let fee = self.fee;
            BTCTx::create(_fbb, &BTCTxArgs { txins, txouts, fee })
        }
    }
    pub enum MessageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Message<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Message<'a> {
        type Inner = Message<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Message<'a> {
        pub const VT_ID_MSG: flatbuffers::VOffsetT = 4;
        pub const VT_ID_TX: flatbuffers::VOffsetT = 6;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
        pub const VT_FROM: flatbuffers::VOffsetT = 12;
        pub const VT_TO: flatbuffers::VOffsetT = 14;
        pub const VT_SUBJECT: flatbuffers::VOffsetT = 16;
        pub const VT_BODY: flatbuffers::VOffsetT = 18;
        pub const VT_READ: flatbuffers::VOffsetT = 20;
        pub const VT_INCOMING: flatbuffers::VOffsetT = 22;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Message { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageArgs<'args>,
        ) -> flatbuffers::WIPOffset<Message<'bldr>> {
            let mut builder = MessageBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.subject {
                builder.add_subject(x);
            }
            if let Some(x) = args.to {
                builder.add_to(x);
            }
            if let Some(x) = args.from {
                builder.add_from(x);
            }
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.add_id_tx(args.id_tx);
            builder.add_id_msg(args.id_msg);
            builder.add_incoming(args.incoming);
            builder.add_read(args.read);
            builder.finish()
        }

        pub fn unpack(&self) -> MessageT {
            let id_msg = self.id_msg();
            let id_tx = self.id_tx();
            let height = self.height();
            let timestamp = self.timestamp();
            let from = self.from().map(|x| x.to_string());
            let to = self.to().map(|x| x.to_string());
            let subject = self.subject().map(|x| x.to_string());
            let body = self.body().map(|x| x.to_string());
            let read = self.read();
            let incoming = self.incoming();
            MessageT {
                id_msg,
                id_tx,
                height,
                timestamp,
                from,
                to,
                subject,
                body,
                read,
                incoming,
            }
        }

        #[inline]
        pub fn id_msg(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Message::VT_ID_MSG, Some(0)).unwrap() }
        }
        #[inline]
        pub fn id_tx(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Message::VT_ID_TX, Some(0)).unwrap() }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Message::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Message::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn from(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_FROM, None)
            }
        }
        #[inline]
        pub fn to(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_TO, None)
            }
        }
        #[inline]
        pub fn subject(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_SUBJECT, None)
            }
        }
        #[inline]
        pub fn body(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_BODY, None)
            }
        }
        #[inline]
        pub fn read(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Message::VT_READ, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn incoming(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Message::VT_INCOMING, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Message<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id_msg", Self::VT_ID_MSG, false)?
                .visit_field::<u32>("id_tx", Self::VT_ID_TX, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("from", Self::VT_FROM, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("to", Self::VT_TO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "subject",
                    Self::VT_SUBJECT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
                .visit_field::<bool>("read", Self::VT_READ, false)?
                .visit_field::<bool>("incoming", Self::VT_INCOMING, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MessageArgs<'a> {
        pub id_msg: u32,
        pub id_tx: u32,
        pub height: u32,
        pub timestamp: u32,
        pub from: Option<flatbuffers::WIPOffset<&'a str>>,
        pub to: Option<flatbuffers::WIPOffset<&'a str>>,
        pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
        pub body: Option<flatbuffers::WIPOffset<&'a str>>,
        pub read: bool,
        pub incoming: bool,
    }
    impl<'a> Default for MessageArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageArgs {
                id_msg: 0,
                id_tx: 0,
                height: 0,
                timestamp: 0,
                from: None,
                to: None,
                subject: None,
                body: None,
                read: false,
                incoming: false,
            }
        }
    }

    pub struct MessageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_id_msg(&mut self, id_msg: u32) {
            self.fbb_.push_slot::<u32>(Message::VT_ID_MSG, id_msg, 0);
        }
        #[inline]
        pub fn add_id_tx(&mut self, id_tx: u32) {
            self.fbb_.push_slot::<u32>(Message::VT_ID_TX, id_tx, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Message::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Message::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_from(&mut self, from: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_FROM, from);
        }
        #[inline]
        pub fn add_to(&mut self, to: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_TO, to);
        }
        #[inline]
        pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SUBJECT, subject);
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_BODY, body);
        }
        #[inline]
        pub fn add_read(&mut self, read: bool) {
            self.fbb_.push_slot::<bool>(Message::VT_READ, read, false);
        }
        #[inline]
        pub fn add_incoming(&mut self, incoming: bool) {
            self.fbb_
                .push_slot::<bool>(Message::VT_INCOMING, incoming, false);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Message<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Message");
            ds.field("id_msg", &self.id_msg());
            ds.field("id_tx", &self.id_tx());
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.field("from", &self.from());
            ds.field("to", &self.to());
            ds.field("subject", &self.subject());
            ds.field("body", &self.body());
            ds.field("read", &self.read());
            ds.field("incoming", &self.incoming());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageT {
        pub id_msg: u32,
        pub id_tx: u32,
        pub height: u32,
        pub timestamp: u32,
        pub from: Option<String>,
        pub to: Option<String>,
        pub subject: Option<String>,
        pub body: Option<String>,
        pub read: bool,
        pub incoming: bool,
    }
    impl Default for MessageT {
        fn default() -> Self {
            Self {
                id_msg: 0,
                id_tx: 0,
                height: 0,
                timestamp: 0,
                from: None,
                to: None,
                subject: None,
                body: None,
                read: false,
                incoming: false,
            }
        }
    }
    impl MessageT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Message<'b>> {
            let id_msg = self.id_msg;
            let id_tx = self.id_tx;
            let height = self.height;
            let timestamp = self.timestamp;
            let from = self.from.as_ref().map(|x| _fbb.create_string(x));
            let to = self.to.as_ref().map(|x| _fbb.create_string(x));
            let subject = self.subject.as_ref().map(|x| _fbb.create_string(x));
            let body = self.body.as_ref().map(|x| _fbb.create_string(x));
            let read = self.read;
            let incoming = self.incoming;
            Message::create(
                _fbb,
                &MessageArgs {
                    id_msg,
                    id_tx,
                    height,
                    timestamp,
                    from,
                    to,
                    subject,
                    body,
                    read,
                    incoming,
                },
            )
        }
    }
    pub enum MessageVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MessageVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MessageVec<'a> {
        type Inner = MessageVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MessageVec<'a> {
        pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MessageVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MessageVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<MessageVec<'bldr>> {
            let mut builder = MessageVecBuilder::new(_fbb);
            if let Some(x) = args.messages {
                builder.add_messages(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> MessageVecT {
            let messages = self
                .messages()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            MessageVecT { messages }
        }

        #[inline]
        pub fn messages(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Message<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Message>>,
                >>(MessageVec::VT_MESSAGES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for MessageVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Message>>,
                >>("messages", Self::VT_MESSAGES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MessageVecArgs<'a> {
        pub messages: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Message<'a>>>,
            >,
        >,
    }
    impl<'a> Default for MessageVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            MessageVecArgs { messages: None }
        }
    }

    pub struct MessageVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MessageVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_messages(
            &mut self,
            messages: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Message<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MessageVec::VT_MESSAGES, messages);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MessageVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MessageVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MessageVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MessageVec");
            ds.field("messages", &self.messages());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct MessageVecT {
        pub messages: Option<Vec<MessageT>>,
    }
    impl Default for MessageVecT {
        fn default() -> Self {
            Self { messages: None }
        }
    }
    impl MessageVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<MessageVec<'b>> {
            let messages = self.messages.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            MessageVec::create(_fbb, &MessageVecArgs { messages })
        }
    }
    pub enum PrevNextOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PrevNext<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PrevNext<'a> {
        type Inner = PrevNext<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PrevNext<'a> {
        pub const VT_PREV: flatbuffers::VOffsetT = 4;
        pub const VT_NEXT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PrevNext { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PrevNextArgs,
        ) -> flatbuffers::WIPOffset<PrevNext<'bldr>> {
            let mut builder = PrevNextBuilder::new(_fbb);
            builder.add_next(args.next);
            builder.add_prev(args.prev);
            builder.finish()
        }

        pub fn unpack(&self) -> PrevNextT {
            let prev = self.prev();
            let next = self.next();
            PrevNextT { prev, next }
        }

        #[inline]
        pub fn prev(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PrevNext::VT_PREV, Some(0)).unwrap() }
        }
        #[inline]
        pub fn next(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(PrevNext::VT_NEXT, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for PrevNext<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("prev", Self::VT_PREV, false)?
                .visit_field::<u32>("next", Self::VT_NEXT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PrevNextArgs {
        pub prev: u32,
        pub next: u32,
    }
    impl<'a> Default for PrevNextArgs {
        #[inline]
        fn default() -> Self {
            PrevNextArgs { prev: 0, next: 0 }
        }
    }

    pub struct PrevNextBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PrevNextBuilder<'a, 'b> {
        #[inline]
        pub fn add_prev(&mut self, prev: u32) {
            self.fbb_.push_slot::<u32>(PrevNext::VT_PREV, prev, 0);
        }
        #[inline]
        pub fn add_next(&mut self, next: u32) {
            self.fbb_.push_slot::<u32>(PrevNext::VT_NEXT, next, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrevNextBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PrevNextBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PrevNext<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PrevNext<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PrevNext");
            ds.field("prev", &self.prev());
            ds.field("next", &self.next());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PrevNextT {
        pub prev: u32,
        pub next: u32,
    }
    impl Default for PrevNextT {
        fn default() -> Self {
            Self { prev: 0, next: 0 }
        }
    }
    impl PrevNextT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<PrevNext<'b>> {
            let prev = self.prev;
            let next = self.next;
            PrevNext::create(_fbb, &PrevNextArgs { prev, next })
        }
    }
    pub enum SendTemplateOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SendTemplate<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SendTemplate<'a> {
        type Inner = SendTemplate<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SendTemplate<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TITLE: flatbuffers::VOffsetT = 6;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 10;
        pub const VT_FIAT_AMOUNT: flatbuffers::VOffsetT = 12;
        pub const VT_FEE_INCLUDED: flatbuffers::VOffsetT = 14;
        pub const VT_FIAT: flatbuffers::VOffsetT = 16;
        pub const VT_INCLUDE_REPLY_TO: flatbuffers::VOffsetT = 18;
        pub const VT_SUBJECT: flatbuffers::VOffsetT = 20;
        pub const VT_BODY: flatbuffers::VOffsetT = 22;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SendTemplate { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SendTemplateArgs<'args>,
        ) -> flatbuffers::WIPOffset<SendTemplate<'bldr>> {
            let mut builder = SendTemplateBuilder::new(_fbb);
            builder.add_fiat_amount(args.fiat_amount);
            builder.add_amount(args.amount);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            if let Some(x) = args.subject {
                builder.add_subject(x);
            }
            if let Some(x) = args.fiat {
                builder.add_fiat(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.title {
                builder.add_title(x);
            }
            builder.add_id(args.id);
            builder.add_include_reply_to(args.include_reply_to);
            builder.add_fee_included(args.fee_included);
            builder.finish()
        }

        pub fn unpack(&self) -> SendTemplateT {
            let id = self.id();
            let title = self.title().map(|x| x.to_string());
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let fiat_amount = self.fiat_amount();
            let fee_included = self.fee_included();
            let fiat = self.fiat().map(|x| x.to_string());
            let include_reply_to = self.include_reply_to();
            let subject = self.subject().map(|x| x.to_string());
            let body = self.body().map(|x| x.to_string());
            SendTemplateT {
                id,
                title,
                address,
                amount,
                fiat_amount,
                fee_included,
                fiat,
                include_reply_to,
                subject,
                body,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(SendTemplate::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn title(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_TITLE, None)
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(SendTemplate::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fiat_amount(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f64>(SendTemplate::VT_FIAT_AMOUNT, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fee_included(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SendTemplate::VT_FEE_INCLUDED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fiat(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_FIAT, None)
            }
        }
        #[inline]
        pub fn include_reply_to(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SendTemplate::VT_INCLUDE_REPLY_TO, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn subject(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_SUBJECT, None)
            }
        }
        #[inline]
        pub fn body(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SendTemplate::VT_BODY, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SendTemplate<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<f64>("fiat_amount", Self::VT_FIAT_AMOUNT, false)?
                .visit_field::<bool>("fee_included", Self::VT_FEE_INCLUDED, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fiat", Self::VT_FIAT, false)?
                .visit_field::<bool>("include_reply_to", Self::VT_INCLUDE_REPLY_TO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "subject",
                    Self::VT_SUBJECT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("body", Self::VT_BODY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SendTemplateArgs<'a> {
        pub id: u32,
        pub title: Option<flatbuffers::WIPOffset<&'a str>>,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub fiat_amount: f64,
        pub fee_included: bool,
        pub fiat: Option<flatbuffers::WIPOffset<&'a str>>,
        pub include_reply_to: bool,
        pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
        pub body: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SendTemplateArgs<'a> {
        #[inline]
        fn default() -> Self {
            SendTemplateArgs {
                id: 0,
                title: None,
                address: None,
                amount: 0,
                fiat_amount: 0.0,
                fee_included: false,
                fiat: None,
                include_reply_to: false,
                subject: None,
                body: None,
            }
        }
    }

    pub struct SendTemplateBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SendTemplateBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(SendTemplate::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_TITLE, title);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_
                .push_slot::<u64>(SendTemplate::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_fiat_amount(&mut self, fiat_amount: f64) {
            self.fbb_
                .push_slot::<f64>(SendTemplate::VT_FIAT_AMOUNT, fiat_amount, 0.0);
        }
        #[inline]
        pub fn add_fee_included(&mut self, fee_included: bool) {
            self.fbb_
                .push_slot::<bool>(SendTemplate::VT_FEE_INCLUDED, fee_included, false);
        }
        #[inline]
        pub fn add_fiat(&mut self, fiat: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_FIAT, fiat);
        }
        #[inline]
        pub fn add_include_reply_to(&mut self, include_reply_to: bool) {
            self.fbb_
                .push_slot::<bool>(SendTemplate::VT_INCLUDE_REPLY_TO, include_reply_to, false);
        }
        #[inline]
        pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_SUBJECT, subject);
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTemplate::VT_BODY, body);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SendTemplateBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SendTemplateBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SendTemplate<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SendTemplate<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SendTemplate");
            ds.field("id", &self.id());
            ds.field("title", &self.title());
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("fiat_amount", &self.fiat_amount());
            ds.field("fee_included", &self.fee_included());
            ds.field("fiat", &self.fiat());
            ds.field("include_reply_to", &self.include_reply_to());
            ds.field("subject", &self.subject());
            ds.field("body", &self.body());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendTemplateT {
        pub id: u32,
        pub title: Option<String>,
        pub address: Option<String>,
        pub amount: u64,
        pub fiat_amount: f64,
        pub fee_included: bool,
        pub fiat: Option<String>,
        pub include_reply_to: bool,
        pub subject: Option<String>,
        pub body: Option<String>,
    }
    impl Default for SendTemplateT {
        fn default() -> Self {
            Self {
                id: 0,
                title: None,
                address: None,
                amount: 0,
                fiat_amount: 0.0,
                fee_included: false,
                fiat: None,
                include_reply_to: false,
                subject: None,
                body: None,
            }
        }
    }
    impl SendTemplateT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<SendTemplate<'b>> {
            let id = self.id;
            let title = self.title.as_ref().map(|x| _fbb.create_string(x));
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let fiat_amount = self.fiat_amount;
            let fee_included = self.fee_included;
            let fiat = self.fiat.as_ref().map(|x| _fbb.create_string(x));
            let include_reply_to = self.include_reply_to;
            let subject = self.subject.as_ref().map(|x| _fbb.create_string(x));
            let body = self.body.as_ref().map(|x| _fbb.create_string(x));
            SendTemplate::create(
                _fbb,
                &SendTemplateArgs {
                    id,
                    title,
                    address,
                    amount,
                    fiat_amount,
                    fee_included,
                    fiat,
                    include_reply_to,
                    subject,
                    body,
                },
            )
        }
    }
    pub enum SendTemplateVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SendTemplateVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SendTemplateVec<'a> {
        type Inner = SendTemplateVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SendTemplateVec<'a> {
        pub const VT_TEMPLATES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SendTemplateVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SendTemplateVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<SendTemplateVec<'bldr>> {
            let mut builder = SendTemplateVecBuilder::new(_fbb);
            if let Some(x) = args.templates {
                builder.add_templates(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SendTemplateVecT {
            let templates = self
                .templates()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            SendTemplateVecT { templates }
        }

        #[inline]
        pub fn templates(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SendTemplate<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SendTemplate>>,
                >>(SendTemplateVec::VT_TEMPLATES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SendTemplateVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SendTemplate>>,
                >>("templates", Self::VT_TEMPLATES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SendTemplateVecArgs<'a> {
        pub templates: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SendTemplate<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SendTemplateVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            SendTemplateVecArgs { templates: None }
        }
    }

    pub struct SendTemplateVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SendTemplateVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_templates(
            &mut self,
            templates: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SendTemplate<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SendTemplateVec::VT_TEMPLATES,
                templates,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SendTemplateVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SendTemplateVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SendTemplateVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SendTemplateVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SendTemplateVec");
            ds.field("templates", &self.templates());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SendTemplateVecT {
        pub templates: Option<Vec<SendTemplateT>>,
    }
    impl Default for SendTemplateVecT {
        fn default() -> Self {
            Self { templates: None }
        }
    }
    impl SendTemplateVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<SendTemplateVec<'b>> {
            let templates = self.templates.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            SendTemplateVec::create(_fbb, &SendTemplateVecArgs { templates })
        }
    }
    pub enum ContactOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Contact<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Contact<'a> {
        type Inner = Contact<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Contact<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_NAME: flatbuffers::VOffsetT = 6;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Contact { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ContactArgs<'args>,
        ) -> flatbuffers::WIPOffset<Contact<'bldr>> {
            let mut builder = ContactBuilder::new(_fbb);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_id(args.id);
            builder.finish()
        }

        pub fn unpack(&self) -> ContactT {
            let id = self.id();
            let name = self.name().map(|x| x.to_string());
            let address = self.address().map(|x| x.to_string());
            ContactT { id, name, address }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Contact::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Contact::VT_NAME, None)
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Contact::VT_ADDRESS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Contact<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ContactArgs<'a> {
        pub id: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ContactArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContactArgs {
                id: 0,
                name: None,
                address: None,
            }
        }
    }

    pub struct ContactBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ContactBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(Contact::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_NAME, name);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_ADDRESS, address);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContactBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ContactBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Contact<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Contact<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Contact");
            ds.field("id", &self.id());
            ds.field("name", &self.name());
            ds.field("address", &self.address());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ContactT {
        pub id: u32,
        pub name: Option<String>,
        pub address: Option<String>,
    }
    impl Default for ContactT {
        fn default() -> Self {
            Self {
                id: 0,
                name: None,
                address: None,
            }
        }
    }
    impl ContactT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Contact<'b>> {
            let id = self.id;
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            Contact::create(_fbb, &ContactArgs { id, name, address })
        }
    }
    pub enum ContactVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ContactVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ContactVec<'a> {
        type Inner = ContactVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ContactVec<'a> {
        pub const VT_CONTACTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ContactVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ContactVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<ContactVec<'bldr>> {
            let mut builder = ContactVecBuilder::new(_fbb);
            if let Some(x) = args.contacts {
                builder.add_contacts(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ContactVecT {
            let contacts = self
                .contacts()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            ContactVecT { contacts }
        }

        #[inline]
        pub fn contacts(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact>>,
                >>(ContactVec::VT_CONTACTS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for ContactVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Contact>>,
                >>("contacts", Self::VT_CONTACTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ContactVecArgs<'a> {
        pub contacts: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ContactVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContactVecArgs { contacts: None }
        }
    }

    pub struct ContactVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ContactVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_contacts(
            &mut self,
            contacts: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Contact<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ContactVec::VT_CONTACTS, contacts);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContactVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ContactVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ContactVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ContactVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ContactVec");
            ds.field("contacts", &self.contacts());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ContactVecT {
        pub contacts: Option<Vec<ContactT>>,
    }
    impl Default for ContactVecT {
        fn default() -> Self {
            Self { contacts: None }
        }
    }
    impl ContactVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ContactVec<'b>> {
            let contacts = self.contacts.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            ContactVec::create(_fbb, &ContactVecArgs { contacts })
        }
    }
    pub enum TxTimeValueOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TxTimeValue<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TxTimeValue<'a> {
        type Inner = TxTimeValue<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TxTimeValue<'a> {
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TxTimeValue { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TxTimeValueArgs,
        ) -> flatbuffers::WIPOffset<TxTimeValue<'bldr>> {
            let mut builder = TxTimeValueBuilder::new(_fbb);
            builder.add_value(args.value);
            builder.add_timestamp(args.timestamp);
            builder.finish()
        }

        pub fn unpack(&self) -> TxTimeValueT {
            let timestamp = self.timestamp();
            let value = self.value();
            TxTimeValueT { timestamp, value }
        }

        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TxTimeValue::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TxTimeValue::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TxTimeValue<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TxTimeValueArgs {
        pub timestamp: u32,
        pub value: u64,
    }
    impl<'a> Default for TxTimeValueArgs {
        #[inline]
        fn default() -> Self {
            TxTimeValueArgs {
                timestamp: 0,
                value: 0,
            }
        }
    }

    pub struct TxTimeValueBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TxTimeValueBuilder<'a, 'b> {
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(TxTimeValue::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_.push_slot::<u64>(TxTimeValue::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TxTimeValueBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TxTimeValueBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TxTimeValue<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TxTimeValue<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TxTimeValue");
            ds.field("timestamp", &self.timestamp());
            ds.field("value", &self.value());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TxTimeValueT {
        pub timestamp: u32,
        pub value: u64,
    }
    impl Default for TxTimeValueT {
        fn default() -> Self {
            Self {
                timestamp: 0,
                value: 0,
            }
        }
    }
    impl TxTimeValueT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<TxTimeValue<'b>> {
            let timestamp = self.timestamp;
            let value = self.value;
            TxTimeValue::create(_fbb, &TxTimeValueArgs { timestamp, value })
        }
    }
    pub enum TxTimeValueVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TxTimeValueVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TxTimeValueVec<'a> {
        type Inner = TxTimeValueVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TxTimeValueVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TxTimeValueVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TxTimeValueVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<TxTimeValueVec<'bldr>> {
            let mut builder = TxTimeValueVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> TxTimeValueVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            TxTimeValueVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxTimeValue<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxTimeValue>>,
                >>(TxTimeValueVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TxTimeValueVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TxTimeValue>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TxTimeValueVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxTimeValue<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TxTimeValueVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            TxTimeValueVecArgs { values: None }
        }
    }

    pub struct TxTimeValueVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TxTimeValueVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TxTimeValue<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TxTimeValueVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TxTimeValueVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TxTimeValueVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TxTimeValueVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TxTimeValueVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TxTimeValueVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TxTimeValueVecT {
        pub values: Option<Vec<TxTimeValueT>>,
    }
    impl Default for TxTimeValueVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl TxTimeValueVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<TxTimeValueVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            TxTimeValueVec::create(_fbb, &TxTimeValueVecArgs { values })
        }
    }
    pub enum QuoteOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Quote<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Quote<'a> {
        type Inner = Quote<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Quote<'a> {
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
        pub const VT_PRICE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Quote { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args QuoteArgs,
        ) -> flatbuffers::WIPOffset<Quote<'bldr>> {
            let mut builder = QuoteBuilder::new(_fbb);
            builder.add_price(args.price);
            builder.add_timestamp(args.timestamp);
            builder.finish()
        }

        pub fn unpack(&self) -> QuoteT {
            let timestamp = self.timestamp();
            let price = self.price();
            QuoteT { timestamp, price }
        }

        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Quote::VT_TIMESTAMP, Some(0)).unwrap() }
        }
        #[inline]
        pub fn price(&self) -> f64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<f64>(Quote::VT_PRICE, Some(0.0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Quote<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .visit_field::<f64>("price", Self::VT_PRICE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct QuoteArgs {
        pub timestamp: u32,
        pub price: f64,
    }
    impl<'a> Default for QuoteArgs {
        #[inline]
        fn default() -> Self {
            QuoteArgs {
                timestamp: 0,
                price: 0.0,
            }
        }
    }

    pub struct QuoteBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> QuoteBuilder<'a, 'b> {
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Quote::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_price(&mut self, price: f64) {
            self.fbb_.push_slot::<f64>(Quote::VT_PRICE, price, 0.0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuoteBuilder<'a, 'b> {
            let start = _fbb.start_table();
            QuoteBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Quote<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Quote<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Quote");
            ds.field("timestamp", &self.timestamp());
            ds.field("price", &self.price());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct QuoteT {
        pub timestamp: u32,
        pub price: f64,
    }
    impl Default for QuoteT {
        fn default() -> Self {
            Self {
                timestamp: 0,
                price: 0.0,
            }
        }
    }
    impl QuoteT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Quote<'b>> {
            let timestamp = self.timestamp;
            let price = self.price;
            Quote::create(_fbb, &QuoteArgs { timestamp, price })
        }
    }
    pub enum QuoteVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct QuoteVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for QuoteVec<'a> {
        type Inner = QuoteVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> QuoteVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            QuoteVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args QuoteVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<QuoteVec<'bldr>> {
            let mut builder = QuoteVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> QuoteVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            QuoteVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Quote<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Quote>>,
                >>(QuoteVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for QuoteVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Quote>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct QuoteVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Quote<'a>>>,
            >,
        >,
    }
    impl<'a> Default for QuoteVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            QuoteVecArgs { values: None }
        }
    }

    pub struct QuoteVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> QuoteVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Quote<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(QuoteVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuoteVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            QuoteVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<QuoteVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for QuoteVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("QuoteVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct QuoteVecT {
        pub values: Option<Vec<QuoteT>>,
    }
    impl Default for QuoteVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl QuoteVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<QuoteVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            QuoteVec::create(_fbb, &QuoteVecArgs { values })
        }
    }
    pub enum SpendingOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Spending<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Spending<'a> {
        type Inner = Spending<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Spending<'a> {
        pub const VT_RECIPIENT: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Spending { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SpendingArgs<'args>,
        ) -> flatbuffers::WIPOffset<Spending<'bldr>> {
            let mut builder = SpendingBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.recipient {
                builder.add_recipient(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SpendingT {
            let recipient = self.recipient().map(|x| x.to_string());
            let amount = self.amount();
            SpendingT { recipient, amount }
        }

        #[inline]
        pub fn recipient(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Spending::VT_RECIPIENT, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Spending::VT_AMOUNT, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Spending<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "recipient",
                    Self::VT_RECIPIENT,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SpendingArgs<'a> {
        pub recipient: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
    }
    impl<'a> Default for SpendingArgs<'a> {
        #[inline]
        fn default() -> Self {
            SpendingArgs {
                recipient: None,
                amount: 0,
            }
        }
    }

    pub struct SpendingBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SpendingBuilder<'a, 'b> {
        #[inline]
        pub fn add_recipient(&mut self, recipient: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Spending::VT_RECIPIENT, recipient);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(Spending::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpendingBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SpendingBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Spending<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Spending<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Spending");
            ds.field("recipient", &self.recipient());
            ds.field("amount", &self.amount());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SpendingT {
        pub recipient: Option<String>,
        pub amount: u64,
    }
    impl Default for SpendingT {
        fn default() -> Self {
            Self {
                recipient: None,
                amount: 0,
            }
        }
    }
    impl SpendingT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Spending<'b>> {
            let recipient = self.recipient.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            Spending::create(_fbb, &SpendingArgs { recipient, amount })
        }
    }
    pub enum SpendingVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SpendingVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SpendingVec<'a> {
        type Inner = SpendingVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SpendingVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SpendingVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SpendingVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<SpendingVec<'bldr>> {
            let mut builder = SpendingVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> SpendingVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            SpendingVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spending<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spending>>,
                >>(SpendingVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SpendingVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Spending>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SpendingVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Spending<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SpendingVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            SpendingVecArgs { values: None }
        }
    }

    pub struct SpendingVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SpendingVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Spending<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SpendingVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpendingVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SpendingVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SpendingVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SpendingVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SpendingVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct SpendingVecT {
        pub values: Option<Vec<SpendingT>>,
    }
    impl Default for SpendingVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl SpendingVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<SpendingVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            SpendingVec::create(_fbb, &SpendingVecArgs { values })
        }
    }
    pub enum AddressBalanceOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AddressBalance<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AddressBalance<'a> {
        type Inner = AddressBalance<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AddressBalance<'a> {
        pub const VT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;
        pub const VT_BALANCE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AddressBalance { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AddressBalanceArgs<'args>,
        ) -> flatbuffers::WIPOffset<AddressBalance<'bldr>> {
            let mut builder = AddressBalanceBuilder::new(_fbb);
            builder.add_balance(args.balance);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_index(args.index);
            builder.finish()
        }

        pub fn unpack(&self) -> AddressBalanceT {
            let index = self.index();
            let address = self.address().map(|x| x.to_string());
            let balance = self.balance();
            AddressBalanceT {
                index,
                address,
                balance,
            }
        }

        #[inline]
        pub fn index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(AddressBalance::VT_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AddressBalance::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn balance(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(AddressBalance::VT_BALANCE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AddressBalance<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("balance", Self::VT_BALANCE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AddressBalanceArgs<'a> {
        pub index: u32,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub balance: u64,
    }
    impl<'a> Default for AddressBalanceArgs<'a> {
        #[inline]
        fn default() -> Self {
            AddressBalanceArgs {
                index: 0,
                address: None,
                balance: 0,
            }
        }
    }

    pub struct AddressBalanceBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AddressBalanceBuilder<'a, 'b> {
        #[inline]
        pub fn add_index(&mut self, index: u32) {
            self.fbb_
                .push_slot::<u32>(AddressBalance::VT_INDEX, index, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AddressBalance::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_balance(&mut self, balance: u64) {
            self.fbb_
                .push_slot::<u64>(AddressBalance::VT_BALANCE, balance, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AddressBalanceBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AddressBalanceBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AddressBalance<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AddressBalance<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AddressBalance");
            ds.field("index", &self.index());
            ds.field("address", &self.address());
            ds.field("balance", &self.balance());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AddressBalanceT {
        pub index: u32,
        pub address: Option<String>,
        pub balance: u64,
    }
    impl Default for AddressBalanceT {
        fn default() -> Self {
            Self {
                index: 0,
                address: None,
                balance: 0,
            }
        }
    }
    impl AddressBalanceT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<AddressBalance<'b>> {
            let index = self.index;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let balance = self.balance;
            AddressBalance::create(
                _fbb,
                &AddressBalanceArgs {
                    index,
                    address,
                    balance,
                },
            )
        }
    }
    pub enum AddressBalanceVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AddressBalanceVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AddressBalanceVec<'a> {
        type Inner = AddressBalanceVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AddressBalanceVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AddressBalanceVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AddressBalanceVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<AddressBalanceVec<'bldr>> {
            let mut builder = AddressBalanceVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AddressBalanceVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            AddressBalanceVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddressBalance<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddressBalance>>,
                >>(AddressBalanceVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AddressBalanceVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AddressBalance>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AddressBalanceVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AddressBalance<'a>>>,
            >,
        >,
    }
    impl<'a> Default for AddressBalanceVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            AddressBalanceVecArgs { values: None }
        }
    }

    pub struct AddressBalanceVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AddressBalanceVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AddressBalance<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AddressBalanceVec::VT_VALUES,
                values,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AddressBalanceVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AddressBalanceVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AddressBalanceVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AddressBalanceVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AddressBalanceVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AddressBalanceVecT {
        pub values: Option<Vec<AddressBalanceT>>,
    }
    impl Default for AddressBalanceVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl AddressBalanceVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<AddressBalanceVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            AddressBalanceVec::create(_fbb, &AddressBalanceVecArgs { values })
        }
    }
    pub enum CheckpointOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Checkpoint<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Checkpoint<'a> {
        type Inner = Checkpoint<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Checkpoint<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Checkpoint { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CheckpointArgs,
        ) -> flatbuffers::WIPOffset<Checkpoint<'bldr>> {
            let mut builder = CheckpointBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            builder.add_height(args.height);
            builder.finish()
        }

        pub fn unpack(&self) -> CheckpointT {
            let height = self.height();
            let timestamp = self.timestamp();
            CheckpointT { height, timestamp }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Checkpoint::VT_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn timestamp(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Checkpoint::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Checkpoint<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CheckpointArgs {
        pub height: u32,
        pub timestamp: u32,
    }
    impl<'a> Default for CheckpointArgs {
        #[inline]
        fn default() -> Self {
            CheckpointArgs {
                height: 0,
                timestamp: 0,
            }
        }
    }

    pub struct CheckpointBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CheckpointBuilder<'a, 'b> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Checkpoint::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u32) {
            self.fbb_
                .push_slot::<u32>(Checkpoint::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CheckpointBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CheckpointBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Checkpoint<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Checkpoint<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Checkpoint");
            ds.field("height", &self.height());
            ds.field("timestamp", &self.timestamp());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct CheckpointT {
        pub height: u32,
        pub timestamp: u32,
    }
    impl Default for CheckpointT {
        fn default() -> Self {
            Self {
                height: 0,
                timestamp: 0,
            }
        }
    }
    impl CheckpointT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Checkpoint<'b>> {
            let height = self.height;
            let timestamp = self.timestamp;
            Checkpoint::create(_fbb, &CheckpointArgs { height, timestamp })
        }
    }
    pub enum CheckpointVecOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CheckpointVec<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CheckpointVec<'a> {
        type Inner = CheckpointVec<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CheckpointVec<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CheckpointVec { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CheckpointVecArgs<'args>,
        ) -> flatbuffers::WIPOffset<CheckpointVec<'bldr>> {
            let mut builder = CheckpointVecBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> CheckpointVecT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            CheckpointVecT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint>>,
                >>(CheckpointVec::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for CheckpointVec<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Checkpoint>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CheckpointVecArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint<'a>>>,
            >,
        >,
    }
    impl<'a> Default for CheckpointVecArgs<'a> {
        #[inline]
        fn default() -> Self {
            CheckpointVecArgs { values: None }
        }
    }

    pub struct CheckpointVecBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CheckpointVecBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Checkpoint<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CheckpointVec::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CheckpointVecBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CheckpointVecBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CheckpointVec<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CheckpointVec<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CheckpointVec");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct CheckpointVecT {
        pub values: Option<Vec<CheckpointT>>,
    }
    impl Default for CheckpointVecT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl CheckpointVecT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<CheckpointVec<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            CheckpointVec::create(_fbb, &CheckpointVecArgs { values })
        }
    }
    pub enum BackupOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Backup<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Backup<'a> {
        type Inner = Backup<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Backup<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_SEED: flatbuffers::VOffsetT = 6;
        pub const VT_INDEX: flatbuffers::VOffsetT = 8;
        pub const VT_SK: flatbuffers::VOffsetT = 10;
        pub const VT_FVK: flatbuffers::VOffsetT = 12;
        pub const VT_UVK: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Backup { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BackupArgs<'args>,
        ) -> flatbuffers::WIPOffset<Backup<'bldr>> {
            let mut builder = BackupBuilder::new(_fbb);
            if let Some(x) = args.uvk {
                builder.add_uvk(x);
            }
            if let Some(x) = args.fvk {
                builder.add_fvk(x);
            }
            if let Some(x) = args.sk {
                builder.add_sk(x);
            }
            builder.add_index(args.index);
            if let Some(x) = args.seed {
                builder.add_seed(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> BackupT {
            let name = self.name().map(|x| x.to_string());
            let seed = self.seed().map(|x| x.to_string());
            let index = self.index();
            let sk = self.sk().map(|x| x.to_string());
            let fvk = self.fvk().map(|x| x.to_string());
            let uvk = self.uvk().map(|x| x.to_string());
            BackupT {
                name,
                seed,
                index,
                sk,
                fvk,
                uvk,
            }
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_NAME, None)
            }
        }
        #[inline]
        pub fn seed(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SEED, None)
            }
        }
        #[inline]
        pub fn index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Backup::VT_INDEX, Some(0)).unwrap() }
        }
        #[inline]
        pub fn sk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_SK, None)
            }
        }
        #[inline]
        pub fn fvk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_FVK, None)
            }
        }
        #[inline]
        pub fn uvk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Backup::VT_UVK, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Backup<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("seed", Self::VT_SEED, false)?
                .visit_field::<u32>("index", Self::VT_INDEX, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sk", Self::VT_SK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fvk", Self::VT_FVK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("uvk", Self::VT_UVK, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BackupArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub seed: Option<flatbuffers::WIPOffset<&'a str>>,
        pub index: u32,
        pub sk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub fvk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub uvk: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for BackupArgs<'a> {
        #[inline]
        fn default() -> Self {
            BackupArgs {
                name: None,
                seed: None,
                index: 0,
                sk: None,
                fvk: None,
                uvk: None,
            }
        }
    }

    pub struct BackupBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BackupBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_NAME, name);
        }
        #[inline]
        pub fn add_seed(&mut self, seed: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SEED, seed);
        }
        #[inline]
        pub fn add_index(&mut self, index: u32) {
            self.fbb_.push_slot::<u32>(Backup::VT_INDEX, index, 0);
        }
        #[inline]
        pub fn add_sk(&mut self, sk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_SK, sk);
        }
        #[inline]
        pub fn add_fvk(&mut self, fvk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_FVK, fvk);
        }
        #[inline]
        pub fn add_uvk(&mut self, uvk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Backup::VT_UVK, uvk);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BackupBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BackupBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Backup<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Backup<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Backup");
            ds.field("name", &self.name());
            ds.field("seed", &self.seed());
            ds.field("index", &self.index());
            ds.field("sk", &self.sk());
            ds.field("fvk", &self.fvk());
            ds.field("uvk", &self.uvk());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BackupT {
        pub name: Option<String>,
        pub seed: Option<String>,
        pub index: u32,
        pub sk: Option<String>,
        pub fvk: Option<String>,
        pub uvk: Option<String>,
    }
    impl Default for BackupT {
        fn default() -> Self {
            Self {
                name: None,
                seed: None,
                index: 0,
                sk: None,
                fvk: None,
                uvk: None,
            }
        }
    }
    impl BackupT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Backup<'b>> {
            let name = self.name.as_ref().map(|x| _fbb.create_string(x));
            let seed = self.seed.as_ref().map(|x| _fbb.create_string(x));
            let index = self.index;
            let sk = self.sk.as_ref().map(|x| _fbb.create_string(x));
            let fvk = self.fvk.as_ref().map(|x| _fbb.create_string(x));
            let uvk = self.uvk.as_ref().map(|x| _fbb.create_string(x));
            Backup::create(
                _fbb,
                &BackupArgs {
                    name,
                    seed,
                    index,
                    sk,
                    fvk,
                    uvk,
                },
            )
        }
    }
    pub enum RaptorQDropsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RaptorQDrops<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RaptorQDrops<'a> {
        type Inner = RaptorQDrops<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RaptorQDrops<'a> {
        pub const VT_DROPS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RaptorQDrops { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RaptorQDropsArgs<'args>,
        ) -> flatbuffers::WIPOffset<RaptorQDrops<'bldr>> {
            let mut builder = RaptorQDropsBuilder::new(_fbb);
            if let Some(x) = args.drops {
                builder.add_drops(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> RaptorQDropsT {
            let drops = self
                .drops()
                .map(|x| x.iter().map(|s| s.to_string()).collect());
            RaptorQDropsT { drops }
        }

        #[inline]
        pub fn drops(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(RaptorQDrops::VT_DROPS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for RaptorQDrops<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("drops", Self::VT_DROPS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RaptorQDropsArgs<'a> {
        pub drops: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for RaptorQDropsArgs<'a> {
        #[inline]
        fn default() -> Self {
            RaptorQDropsArgs { drops: None }
        }
    }

    pub struct RaptorQDropsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RaptorQDropsBuilder<'a, 'b> {
        #[inline]
        pub fn add_drops(
            &mut self,
            drops: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RaptorQDrops::VT_DROPS, drops);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RaptorQDropsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RaptorQDropsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RaptorQDrops<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RaptorQDrops<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RaptorQDrops");
            ds.field("drops", &self.drops());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RaptorQDropsT {
        pub drops: Option<Vec<String>>,
    }
    impl Default for RaptorQDropsT {
        fn default() -> Self {
            Self { drops: None }
        }
    }
    impl RaptorQDropsT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<RaptorQDrops<'b>> {
            let drops = self.drops.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                _fbb.create_vector(&w)
            });
            RaptorQDrops::create(_fbb, &RaptorQDropsArgs { drops })
        }
    }
    pub enum AGEKeysOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AGEKeys<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AGEKeys<'a> {
        type Inner = AGEKeys<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AGEKeys<'a> {
        pub const VT_SK: flatbuffers::VOffsetT = 4;
        pub const VT_PK: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AGEKeys { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AGEKeysArgs<'args>,
        ) -> flatbuffers::WIPOffset<AGEKeys<'bldr>> {
            let mut builder = AGEKeysBuilder::new(_fbb);
            if let Some(x) = args.pk {
                builder.add_pk(x);
            }
            if let Some(x) = args.sk {
                builder.add_sk(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> AGEKeysT {
            let sk = self.sk().map(|x| x.to_string());
            let pk = self.pk().map(|x| x.to_string());
            AGEKeysT { sk, pk }
        }

        #[inline]
        pub fn sk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AGEKeys::VT_SK, None)
            }
        }
        #[inline]
        pub fn pk(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AGEKeys::VT_PK, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AGEKeys<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sk", Self::VT_SK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pk", Self::VT_PK, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AGEKeysArgs<'a> {
        pub sk: Option<flatbuffers::WIPOffset<&'a str>>,
        pub pk: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for AGEKeysArgs<'a> {
        #[inline]
        fn default() -> Self {
            AGEKeysArgs { sk: None, pk: None }
        }
    }

    pub struct AGEKeysBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AGEKeysBuilder<'a, 'b> {
        #[inline]
        pub fn add_sk(&mut self, sk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AGEKeys::VT_SK, sk);
        }
        #[inline]
        pub fn add_pk(&mut self, pk: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AGEKeys::VT_PK, pk);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AGEKeysBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AGEKeysBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AGEKeys<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AGEKeys<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AGEKeys");
            ds.field("sk", &self.sk());
            ds.field("pk", &self.pk());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct AGEKeysT {
        pub sk: Option<String>,
        pub pk: Option<String>,
    }
    impl Default for AGEKeysT {
        fn default() -> Self {
            Self { sk: None, pk: None }
        }
    }
    impl AGEKeysT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<AGEKeys<'b>> {
            let sk = self.sk.as_ref().map(|x| _fbb.create_string(x));
            let pk = self.pk.as_ref().map(|x| _fbb.create_string(x));
            AGEKeys::create(_fbb, &AGEKeysArgs { sk, pk })
        }
    }
    pub enum ServersOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Servers<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Servers<'a> {
        type Inner = Servers<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Servers<'a> {
        pub const VT_URLS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Servers { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ServersArgs<'args>,
        ) -> flatbuffers::WIPOffset<Servers<'bldr>> {
            let mut builder = ServersBuilder::new(_fbb);
            if let Some(x) = args.urls {
                builder.add_urls(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ServersT {
            let urls = self
                .urls()
                .map(|x| x.iter().map(|s| s.to_string()).collect());
            ServersT { urls }
        }

        #[inline]
        pub fn urls(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Servers::VT_URLS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Servers<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("urls", Self::VT_URLS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ServersArgs<'a> {
        pub urls: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for ServersArgs<'a> {
        #[inline]
        fn default() -> Self {
            ServersArgs { urls: None }
        }
    }

    pub struct ServersBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ServersBuilder<'a, 'b> {
        #[inline]
        pub fn add_urls(
            &mut self,
            urls: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Servers::VT_URLS, urls);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ServersBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ServersBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Servers<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Servers<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Servers");
            ds.field("urls", &self.urls());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ServersT {
        pub urls: Option<Vec<String>>,
    }
    impl Default for ServersT {
        fn default() -> Self {
            Self { urls: None }
        }
    }
    impl ServersT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Servers<'b>> {
            let urls = self.urls.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                _fbb.create_vector(&w)
            });
            Servers::create(_fbb, &ServersArgs { urls })
        }
    }
    pub enum ProgressOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Progress<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Progress<'a> {
        type Inner = Progress<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Progress<'a> {
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
        pub const VT_TRIAL_DECRYPTIONS: flatbuffers::VOffsetT = 6;
        pub const VT_DOWNLOADED: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Progress { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ProgressArgs,
        ) -> flatbuffers::WIPOffset<Progress<'bldr>> {
            let mut builder = ProgressBuilder::new(_fbb);
            builder.add_downloaded(args.downloaded);
            builder.add_trial_decryptions(args.trial_decryptions);
            builder.add_height(args.height);
            builder.finish()
        }

        pub fn unpack(&self) -> ProgressT {
            let height = self.height();
            let trial_decryptions = self.trial_decryptions();
            let downloaded = self.downloaded();
            ProgressT {
                height,
                trial_decryptions,
                downloaded,
            }
        }

        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Progress::VT_HEIGHT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn trial_decryptions(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Progress::VT_TRIAL_DECRYPTIONS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn downloaded(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Progress::VT_DOWNLOADED, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Progress<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<u64>("trial_decryptions", Self::VT_TRIAL_DECRYPTIONS, false)?
                .visit_field::<u64>("downloaded", Self::VT_DOWNLOADED, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ProgressArgs {
        pub height: u32,
        pub trial_decryptions: u64,
        pub downloaded: u64,
    }
    impl<'a> Default for ProgressArgs {
        #[inline]
        fn default() -> Self {
            ProgressArgs {
                height: 0,
                trial_decryptions: 0,
                downloaded: 0,
            }
        }
    }

    pub struct ProgressBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ProgressBuilder<'a, 'b> {
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(Progress::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_trial_decryptions(&mut self, trial_decryptions: u64) {
            self.fbb_
                .push_slot::<u64>(Progress::VT_TRIAL_DECRYPTIONS, trial_decryptions, 0);
        }
        #[inline]
        pub fn add_downloaded(&mut self, downloaded: u64) {
            self.fbb_
                .push_slot::<u64>(Progress::VT_DOWNLOADED, downloaded, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProgressBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ProgressBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Progress<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Progress<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Progress");
            ds.field("height", &self.height());
            ds.field("trial_decryptions", &self.trial_decryptions());
            ds.field("downloaded", &self.downloaded());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ProgressT {
        pub height: u32,
        pub trial_decryptions: u64,
        pub downloaded: u64,
    }
    impl Default for ProgressT {
        fn default() -> Self {
            Self {
                height: 0,
                trial_decryptions: 0,
                downloaded: 0,
            }
        }
    }
    impl ProgressT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Progress<'b>> {
            let height = self.height;
            let trial_decryptions = self.trial_decryptions;
            let downloaded = self.downloaded;
            Progress::create(
                _fbb,
                &ProgressArgs {
                    height,
                    trial_decryptions,
                    downloaded,
                },
            )
        }
    }
    pub enum KeyPackOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct KeyPack<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for KeyPack<'a> {
        type Inner = KeyPack<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> KeyPack<'a> {
        pub const VT_T_ADDR: flatbuffers::VOffsetT = 4;
        pub const VT_T_KEY: flatbuffers::VOffsetT = 6;
        pub const VT_Z_ADDR: flatbuffers::VOffsetT = 8;
        pub const VT_Z_KEY: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            KeyPack { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args KeyPackArgs<'args>,
        ) -> flatbuffers::WIPOffset<KeyPack<'bldr>> {
            let mut builder = KeyPackBuilder::new(_fbb);
            if let Some(x) = args.z_key {
                builder.add_z_key(x);
            }
            if let Some(x) = args.z_addr {
                builder.add_z_addr(x);
            }
            if let Some(x) = args.t_key {
                builder.add_t_key(x);
            }
            if let Some(x) = args.t_addr {
                builder.add_t_addr(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> KeyPackT {
            let t_addr = self.t_addr().map(|x| x.to_string());
            let t_key = self.t_key().map(|x| x.to_string());
            let z_addr = self.z_addr().map(|x| x.to_string());
            let z_key = self.z_key().map(|x| x.to_string());
            KeyPackT {
                t_addr,
                t_key,
                z_addr,
                z_key,
            }
        }

        #[inline]
        pub fn t_addr(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyPack::VT_T_ADDR, None)
            }
        }
        #[inline]
        pub fn t_key(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyPack::VT_T_KEY, None)
            }
        }
        #[inline]
        pub fn z_addr(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyPack::VT_Z_ADDR, None)
            }
        }
        #[inline]
        pub fn z_key(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(KeyPack::VT_Z_KEY, None)
            }
        }
    }

    impl flatbuffers::Verifiable for KeyPack<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "t_addr",
                    Self::VT_T_ADDR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("t_key", Self::VT_T_KEY, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "z_addr",
                    Self::VT_Z_ADDR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("z_key", Self::VT_Z_KEY, false)?
                .finish();
            Ok(())
        }
    }
    pub struct KeyPackArgs<'a> {
        pub t_addr: Option<flatbuffers::WIPOffset<&'a str>>,
        pub t_key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub z_addr: Option<flatbuffers::WIPOffset<&'a str>>,
        pub z_key: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for KeyPackArgs<'a> {
        #[inline]
        fn default() -> Self {
            KeyPackArgs {
                t_addr: None,
                t_key: None,
                z_addr: None,
                z_key: None,
            }
        }
    }

    pub struct KeyPackBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> KeyPackBuilder<'a, 'b> {
        #[inline]
        pub fn add_t_addr(&mut self, t_addr: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyPack::VT_T_ADDR, t_addr);
        }
        #[inline]
        pub fn add_t_key(&mut self, t_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyPack::VT_T_KEY, t_key);
        }
        #[inline]
        pub fn add_z_addr(&mut self, z_addr: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyPack::VT_Z_ADDR, z_addr);
        }
        #[inline]
        pub fn add_z_key(&mut self, z_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(KeyPack::VT_Z_KEY, z_key);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyPackBuilder<'a, 'b> {
            let start = _fbb.start_table();
            KeyPackBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<KeyPack<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for KeyPack<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("KeyPack");
            ds.field("t_addr", &self.t_addr());
            ds.field("t_key", &self.t_key());
            ds.field("z_addr", &self.z_addr());
            ds.field("z_key", &self.z_key());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct KeyPackT {
        pub t_addr: Option<String>,
        pub t_key: Option<String>,
        pub z_addr: Option<String>,
        pub z_key: Option<String>,
    }
    impl Default for KeyPackT {
        fn default() -> Self {
            Self {
                t_addr: None,
                t_key: None,
                z_addr: None,
                z_key: None,
            }
        }
    }
    impl KeyPackT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<KeyPack<'b>> {
            let t_addr = self.t_addr.as_ref().map(|x| _fbb.create_string(x));
            let t_key = self.t_key.as_ref().map(|x| _fbb.create_string(x));
            let z_addr = self.z_addr.as_ref().map(|x| _fbb.create_string(x));
            let z_key = self.z_key.as_ref().map(|x| _fbb.create_string(x));
            KeyPack::create(
                _fbb,
                &KeyPackArgs {
                    t_addr,
                    t_key,
                    z_addr,
                    z_key,
                },
            )
        }
    }
    pub enum RecipientOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Recipient<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Recipient<'a> {
        type Inner = Recipient<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Recipient<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_FEE_INCLUDED: flatbuffers::VOffsetT = 8;
        pub const VT_REPLY_TO: flatbuffers::VOffsetT = 10;
        pub const VT_SUBJECT: flatbuffers::VOffsetT = 12;
        pub const VT_MEMO: flatbuffers::VOffsetT = 14;
        pub const VT_MAX_AMOUNT_PER_NOTE: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Recipient { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RecipientArgs<'args>,
        ) -> flatbuffers::WIPOffset<Recipient<'bldr>> {
            let mut builder = RecipientBuilder::new(_fbb);
            builder.add_max_amount_per_note(args.max_amount_per_note);
            builder.add_amount(args.amount);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.subject {
                builder.add_subject(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_reply_to(args.reply_to);
            builder.add_fee_included(args.fee_included);
            builder.finish()
        }

        pub fn unpack(&self) -> RecipientT {
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let fee_included = self.fee_included();
            let reply_to = self.reply_to();
            let subject = self.subject().map(|x| x.to_string());
            let memo = self.memo().map(|x| x.to_string());
            let max_amount_per_note = self.max_amount_per_note();
            RecipientT {
                address,
                amount,
                fee_included,
                reply_to,
                subject,
                memo,
                max_amount_per_note,
            }
        }

        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Recipient::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Recipient::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn fee_included(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Recipient::VT_FEE_INCLUDED, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn reply_to(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Recipient::VT_REPLY_TO, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn subject(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Recipient::VT_SUBJECT, None)
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Recipient::VT_MEMO, None)
            }
        }
        #[inline]
        pub fn max_amount_per_note(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(Recipient::VT_MAX_AMOUNT_PER_NOTE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Recipient<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<bool>("fee_included", Self::VT_FEE_INCLUDED, false)?
                .visit_field::<bool>("reply_to", Self::VT_REPLY_TO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "subject",
                    Self::VT_SUBJECT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .visit_field::<u64>("max_amount_per_note", Self::VT_MAX_AMOUNT_PER_NOTE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RecipientArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub fee_included: bool,
        pub reply_to: bool,
        pub subject: Option<flatbuffers::WIPOffset<&'a str>>,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
        pub max_amount_per_note: u64,
    }
    impl<'a> Default for RecipientArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecipientArgs {
                address: None,
                amount: 0,
                fee_included: false,
                reply_to: false,
                subject: None,
                memo: None,
                max_amount_per_note: 0,
            }
        }
    }

    pub struct RecipientBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RecipientBuilder<'a, 'b> {
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipient::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(Recipient::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_fee_included(&mut self, fee_included: bool) {
            self.fbb_
                .push_slot::<bool>(Recipient::VT_FEE_INCLUDED, fee_included, false);
        }
        #[inline]
        pub fn add_reply_to(&mut self, reply_to: bool) {
            self.fbb_
                .push_slot::<bool>(Recipient::VT_REPLY_TO, reply_to, false);
        }
        #[inline]
        pub fn add_subject(&mut self, subject: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipient::VT_SUBJECT, subject);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipient::VT_MEMO, memo);
        }
        #[inline]
        pub fn add_max_amount_per_note(&mut self, max_amount_per_note: u64) {
            self.fbb_
                .push_slot::<u64>(Recipient::VT_MAX_AMOUNT_PER_NOTE, max_amount_per_note, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecipientBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RecipientBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Recipient<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Recipient<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Recipient");
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("fee_included", &self.fee_included());
            ds.field("reply_to", &self.reply_to());
            ds.field("subject", &self.subject());
            ds.field("memo", &self.memo());
            ds.field("max_amount_per_note", &self.max_amount_per_note());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecipientT {
        pub address: Option<String>,
        pub amount: u64,
        pub fee_included: bool,
        pub reply_to: bool,
        pub subject: Option<String>,
        pub memo: Option<String>,
        pub max_amount_per_note: u64,
    }
    impl Default for RecipientT {
        fn default() -> Self {
            Self {
                address: None,
                amount: 0,
                fee_included: false,
                reply_to: false,
                subject: None,
                memo: None,
                max_amount_per_note: 0,
            }
        }
    }
    impl RecipientT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Recipient<'b>> {
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let fee_included = self.fee_included;
            let reply_to = self.reply_to;
            let subject = self.subject.as_ref().map(|x| _fbb.create_string(x));
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            let max_amount_per_note = self.max_amount_per_note;
            Recipient::create(
                _fbb,
                &RecipientArgs {
                    address,
                    amount,
                    fee_included,
                    reply_to,
                    subject,
                    memo,
                    max_amount_per_note,
                },
            )
        }
    }
    pub enum RecipientsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Recipients<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Recipients<'a> {
        type Inner = Recipients<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Recipients<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Recipients { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RecipientsArgs<'args>,
        ) -> flatbuffers::WIPOffset<Recipients<'bldr>> {
            let mut builder = RecipientsBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> RecipientsT {
            let values = self
                .values()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            RecipientsT { values }
        }

        #[inline]
        pub fn values(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient>>,
                >>(Recipients::VT_VALUES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Recipients<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Recipient>>,
                >>("values", Self::VT_VALUES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RecipientsArgs<'a> {
        pub values: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Recipient<'a>>>,
            >,
        >,
    }
    impl<'a> Default for RecipientsArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecipientsArgs { values: None }
        }
    }

    pub struct RecipientsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RecipientsBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(
            &mut self,
            values: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Recipient<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Recipients::VT_VALUES, values);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecipientsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RecipientsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Recipients<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Recipients<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Recipients");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecipientsT {
        pub values: Option<Vec<RecipientT>>,
    }
    impl Default for RecipientsT {
        fn default() -> Self {
            Self { values: None }
        }
    }
    impl RecipientsT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<Recipients<'b>> {
            let values = self.values.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            Recipients::create(_fbb, &RecipientsArgs { values })
        }
    }
    pub enum RecipientSummaryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RecipientSummary<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RecipientSummary<'a> {
        type Inner = RecipientSummary<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RecipientSummary<'a> {
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RecipientSummary { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RecipientSummaryArgs<'args>,
        ) -> flatbuffers::WIPOffset<RecipientSummary<'bldr>> {
            let mut builder = RecipientSummaryBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> RecipientSummaryT {
            let amount = self.amount();
            let address = self.address().map(|x| x.to_string());
            RecipientSummaryT { amount, address }
        }

        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(RecipientSummary::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(RecipientSummary::VT_ADDRESS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for RecipientSummary<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RecipientSummaryArgs<'a> {
        pub amount: u64,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for RecipientSummaryArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecipientSummaryArgs {
                amount: 0,
                address: None,
            }
        }
    }

    pub struct RecipientSummaryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RecipientSummaryBuilder<'a, 'b> {
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_
                .push_slot::<u64>(RecipientSummary::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RecipientSummary::VT_ADDRESS,
                address,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RecipientSummaryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RecipientSummaryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RecipientSummary<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RecipientSummary<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RecipientSummary");
            ds.field("amount", &self.amount());
            ds.field("address", &self.address());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct RecipientSummaryT {
        pub amount: u64,
        pub address: Option<String>,
    }
    impl Default for RecipientSummaryT {
        fn default() -> Self {
            Self {
                amount: 0,
                address: None,
            }
        }
    }
    impl RecipientSummaryT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<RecipientSummary<'b>> {
            let amount = self.amount;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            RecipientSummary::create(_fbb, &RecipientSummaryArgs { amount, address })
        }
    }
    pub enum UnsignedTxSummaryOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnsignedTxSummary<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsignedTxSummary<'a> {
        type Inner = UnsignedTxSummary<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnsignedTxSummary<'a> {
        pub const VT_RECIPIENTS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsignedTxSummary { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnsignedTxSummaryArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnsignedTxSummary<'bldr>> {
            let mut builder = UnsignedTxSummaryBuilder::new(_fbb);
            if let Some(x) = args.recipients {
                builder.add_recipients(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> UnsignedTxSummaryT {
            let recipients = self
                .recipients()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            UnsignedTxSummaryT { recipients }
        }

        #[inline]
        pub fn recipients(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RecipientSummary<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RecipientSummary>>,
                >>(UnsignedTxSummary::VT_RECIPIENTS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for UnsignedTxSummary<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RecipientSummary>>,
                >>("recipients", Self::VT_RECIPIENTS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UnsignedTxSummaryArgs<'a> {
        pub recipients: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RecipientSummary<'a>>>,
            >,
        >,
    }
    impl<'a> Default for UnsignedTxSummaryArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnsignedTxSummaryArgs { recipients: None }
        }
    }

    pub struct UnsignedTxSummaryBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsignedTxSummaryBuilder<'a, 'b> {
        #[inline]
        pub fn add_recipients(
            &mut self,
            recipients: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RecipientSummary<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UnsignedTxSummary::VT_RECIPIENTS,
                recipients,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsignedTxSummaryBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsignedTxSummaryBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsignedTxSummary<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnsignedTxSummary<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnsignedTxSummary");
            ds.field("recipients", &self.recipients());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct UnsignedTxSummaryT {
        pub recipients: Option<Vec<RecipientSummaryT>>,
    }
    impl Default for UnsignedTxSummaryT {
        fn default() -> Self {
            Self { recipients: None }
        }
    }
    impl UnsignedTxSummaryT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<UnsignedTxSummary<'b>> {
            let recipients = self.recipients.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            UnsignedTxSummary::create(_fbb, &UnsignedTxSummaryArgs { recipients })
        }
    }
    pub enum TxOutputOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TxOutput<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TxOutput<'a> {
        type Inner = TxOutput<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TxOutput<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_POOL: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TxOutput { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TxOutputArgs<'args>,
        ) -> flatbuffers::WIPOffset<TxOutput<'bldr>> {
            let mut builder = TxOutputBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.add_id(args.id);
            builder.add_pool(args.pool);
            builder.finish()
        }

        pub fn unpack(&self) -> TxOutputT {
            let id = self.id();
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let pool = self.pool();
            TxOutputT {
                id,
                address,
                amount,
                pool,
            }
        }

        #[inline]
        pub fn id(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(TxOutput::VT_ID, Some(0)).unwrap() }
        }
        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TxOutput::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TxOutput::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn pool(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u8>(TxOutput::VT_POOL, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for TxOutput<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("id", Self::VT_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<u8>("pool", Self::VT_POOL, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TxOutputArgs<'a> {
        pub id: u32,
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub pool: u8,
    }
    impl<'a> Default for TxOutputArgs<'a> {
        #[inline]
        fn default() -> Self {
            TxOutputArgs {
                id: 0,
                address: None,
                amount: 0,
                pool: 0,
            }
        }
    }

    pub struct TxOutputBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TxOutputBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: u32) {
            self.fbb_.push_slot::<u32>(TxOutput::VT_ID, id, 0);
        }
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TxOutput::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(TxOutput::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_pool(&mut self, pool: u8) {
            self.fbb_.push_slot::<u8>(TxOutput::VT_POOL, pool, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TxOutputBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TxOutputBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TxOutput<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TxOutput<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TxOutput");
            ds.field("id", &self.id());
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("pool", &self.pool());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TxOutputT {
        pub id: u32,
        pub address: Option<String>,
        pub amount: u64,
        pub pool: u8,
    }
    impl Default for TxOutputT {
        fn default() -> Self {
            Self {
                id: 0,
                address: None,
                amount: 0,
                pool: 0,
            }
        }
    }
    impl TxOutputT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<TxOutput<'b>> {
            let id = self.id;
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let pool = self.pool;
            TxOutput::create(
                _fbb,
                &TxOutputArgs {
                    id,
                    address,
                    amount,
                    pool,
                },
            )
        }
    }
    pub enum TxReportOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TxReport<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TxReport<'a> {
        type Inner = TxReport<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TxReport<'a> {
        pub const VT_OUTPUTS: flatbuffers::VOffsetT = 4;
        pub const VT_TRANSPARENT: flatbuffers::VOffsetT = 6;
        pub const VT_SAPLING: flatbuffers::VOffsetT = 8;
        pub const VT_ORCHARD: flatbuffers::VOffsetT = 10;
        pub const VT_NET_SAPLING: flatbuffers::VOffsetT = 12;
        pub const VT_NET_ORCHARD: flatbuffers::VOffsetT = 14;
        pub const VT_FEE: flatbuffers::VOffsetT = 16;
        pub const VT_PRIVACY_LEVEL: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TxReport { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TxReportArgs<'args>,
        ) -> flatbuffers::WIPOffset<TxReport<'bldr>> {
            let mut builder = TxReportBuilder::new(_fbb);
            builder.add_fee(args.fee);
            builder.add_net_orchard(args.net_orchard);
            builder.add_net_sapling(args.net_sapling);
            builder.add_orchard(args.orchard);
            builder.add_sapling(args.sapling);
            builder.add_transparent(args.transparent);
            if let Some(x) = args.outputs {
                builder.add_outputs(x);
            }
            builder.add_privacy_level(args.privacy_level);
            builder.finish()
        }

        pub fn unpack(&self) -> TxReportT {
            let outputs = self
                .outputs()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let transparent = self.transparent();
            let sapling = self.sapling();
            let orchard = self.orchard();
            let net_sapling = self.net_sapling();
            let net_orchard = self.net_orchard();
            let fee = self.fee();
            let privacy_level = self.privacy_level();
            TxReportT {
                outputs,
                transparent,
                sapling,
                orchard,
                net_sapling,
                net_orchard,
                fee,
                privacy_level,
            }
        }

        #[inline]
        pub fn outputs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxOutput<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxOutput>>,
                >>(TxReport::VT_OUTPUTS, None)
            }
        }
        #[inline]
        pub fn transparent(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(TxReport::VT_TRANSPARENT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sapling(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TxReport::VT_SAPLING, Some(0)).unwrap() }
        }
        #[inline]
        pub fn orchard(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TxReport::VT_ORCHARD, Some(0)).unwrap() }
        }
        #[inline]
        pub fn net_sapling(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TxReport::VT_NET_SAPLING, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn net_orchard(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(TxReport::VT_NET_ORCHARD, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fee(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(TxReport::VT_FEE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn privacy_level(&self) -> u8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u8>(TxReport::VT_PRIVACY_LEVEL, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TxReport<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TxOutput>>,
                >>("outputs", Self::VT_OUTPUTS, false)?
                .visit_field::<u64>("transparent", Self::VT_TRANSPARENT, false)?
                .visit_field::<u64>("sapling", Self::VT_SAPLING, false)?
                .visit_field::<u64>("orchard", Self::VT_ORCHARD, false)?
                .visit_field::<i64>("net_sapling", Self::VT_NET_SAPLING, false)?
                .visit_field::<i64>("net_orchard", Self::VT_NET_ORCHARD, false)?
                .visit_field::<u64>("fee", Self::VT_FEE, false)?
                .visit_field::<u8>("privacy_level", Self::VT_PRIVACY_LEVEL, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TxReportArgs<'a> {
        pub outputs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TxOutput<'a>>>,
            >,
        >,
        pub transparent: u64,
        pub sapling: u64,
        pub orchard: u64,
        pub net_sapling: i64,
        pub net_orchard: i64,
        pub fee: u64,
        pub privacy_level: u8,
    }
    impl<'a> Default for TxReportArgs<'a> {
        #[inline]
        fn default() -> Self {
            TxReportArgs {
                outputs: None,
                transparent: 0,
                sapling: 0,
                orchard: 0,
                net_sapling: 0,
                net_orchard: 0,
                fee: 0,
                privacy_level: 0,
            }
        }
    }

    pub struct TxReportBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TxReportBuilder<'a, 'b> {
        #[inline]
        pub fn add_outputs(
            &mut self,
            outputs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TxOutput<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TxReport::VT_OUTPUTS, outputs);
        }
        #[inline]
        pub fn add_transparent(&mut self, transparent: u64) {
            self.fbb_
                .push_slot::<u64>(TxReport::VT_TRANSPARENT, transparent, 0);
        }
        #[inline]
        pub fn add_sapling(&mut self, sapling: u64) {
            self.fbb_.push_slot::<u64>(TxReport::VT_SAPLING, sapling, 0);
        }
        #[inline]
        pub fn add_orchard(&mut self, orchard: u64) {
            self.fbb_.push_slot::<u64>(TxReport::VT_ORCHARD, orchard, 0);
        }
        #[inline]
        pub fn add_net_sapling(&mut self, net_sapling: i64) {
            self.fbb_
                .push_slot::<i64>(TxReport::VT_NET_SAPLING, net_sapling, 0);
        }
        #[inline]
        pub fn add_net_orchard(&mut self, net_orchard: i64) {
            self.fbb_
                .push_slot::<i64>(TxReport::VT_NET_ORCHARD, net_orchard, 0);
        }
        #[inline]
        pub fn add_fee(&mut self, fee: u64) {
            self.fbb_.push_slot::<u64>(TxReport::VT_FEE, fee, 0);
        }
        #[inline]
        pub fn add_privacy_level(&mut self, privacy_level: u8) {
            self.fbb_
                .push_slot::<u8>(TxReport::VT_PRIVACY_LEVEL, privacy_level, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TxReportBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TxReportBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TxReport<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TxReport<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TxReport");
            ds.field("outputs", &self.outputs());
            ds.field("transparent", &self.transparent());
            ds.field("sapling", &self.sapling());
            ds.field("orchard", &self.orchard());
            ds.field("net_sapling", &self.net_sapling());
            ds.field("net_orchard", &self.net_orchard());
            ds.field("fee", &self.fee());
            ds.field("privacy_level", &self.privacy_level());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct TxReportT {
        pub outputs: Option<Vec<TxOutputT>>,
        pub transparent: u64,
        pub sapling: u64,
        pub orchard: u64,
        pub net_sapling: i64,
        pub net_orchard: i64,
        pub fee: u64,
        pub privacy_level: u8,
    }
    impl Default for TxReportT {
        fn default() -> Self {
            Self {
                outputs: None,
                transparent: 0,
                sapling: 0,
                orchard: 0,
                net_sapling: 0,
                net_orchard: 0,
                fee: 0,
                privacy_level: 0,
            }
        }
    }
    impl TxReportT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<TxReport<'b>> {
            let outputs = self.outputs.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let transparent = self.transparent;
            let sapling = self.sapling;
            let orchard = self.orchard;
            let net_sapling = self.net_sapling;
            let net_orchard = self.net_orchard;
            let fee = self.fee;
            let privacy_level = self.privacy_level;
            TxReport::create(
                _fbb,
                &TxReportArgs {
                    outputs,
                    transparent,
                    sapling,
                    orchard,
                    net_sapling,
                    net_orchard,
                    fee,
                    privacy_level,
                },
            )
        }
    }
    pub enum ETHTransactionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ETHTransaction<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ETHTransaction<'a> {
        type Inner = ETHTransaction<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ETHTransaction<'a> {
        pub const VT_CHAIN_ID: flatbuffers::VOffsetT = 4;
        pub const VT_TO: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_GAS: flatbuffers::VOffsetT = 12;
        pub const VT_MAX_FEE_PER_GAS: flatbuffers::VOffsetT = 14;
        pub const VT_MAX_PRIORITY_FEE_PER_GAS: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ETHTransaction { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ETHTransactionArgs<'args>,
        ) -> flatbuffers::WIPOffset<ETHTransaction<'bldr>> {
            let mut builder = ETHTransactionBuilder::new(_fbb);
            builder.add_max_priority_fee_per_gas(args.max_priority_fee_per_gas);
            builder.add_max_fee_per_gas(args.max_fee_per_gas);
            builder.add_gas(args.gas);
            builder.add_value(args.value);
            builder.add_chain_id(args.chain_id);
            builder.add_nonce(args.nonce);
            if let Some(x) = args.to {
                builder.add_to(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ETHTransactionT {
            let chain_id = self.chain_id();
            let to = self.to().map(|x| x.to_string());
            let value = self.value();
            let nonce = self.nonce();
            let gas = self.gas();
            let max_fee_per_gas = self.max_fee_per_gas();
            let max_priority_fee_per_gas = self.max_priority_fee_per_gas();
            ETHTransactionT {
                chain_id,
                to,
                value,
                nonce,
                gas,
                max_fee_per_gas,
                max_priority_fee_per_gas,
            }
        }

        #[inline]
        pub fn chain_id(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ETHTransaction::VT_CHAIN_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn to(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ETHTransaction::VT_TO, None)
            }
        }
        #[inline]
        pub fn value(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ETHTransaction::VT_VALUE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn nonce(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(ETHTransaction::VT_NONCE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn gas(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ETHTransaction::VT_GAS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn max_fee_per_gas(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ETHTransaction::VT_MAX_FEE_PER_GAS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn max_priority_fee_per_gas(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ETHTransaction::VT_MAX_PRIORITY_FEE_PER_GAS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ETHTransaction<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u64>("chain_id", Self::VT_CHAIN_ID, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("to", Self::VT_TO, false)?
                .visit_field::<u64>("value", Self::VT_VALUE, false)?
                .visit_field::<u32>("nonce", Self::VT_NONCE, false)?
                .visit_field::<u64>("gas", Self::VT_GAS, false)?
                .visit_field::<u64>("max_fee_per_gas", Self::VT_MAX_FEE_PER_GAS, false)?
                .visit_field::<u64>(
                    "max_priority_fee_per_gas",
                    Self::VT_MAX_PRIORITY_FEE_PER_GAS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ETHTransactionArgs<'a> {
        pub chain_id: u64,
        pub to: Option<flatbuffers::WIPOffset<&'a str>>,
        pub value: u64,
        pub nonce: u32,
        pub gas: u64,
        pub max_fee_per_gas: u64,
        pub max_priority_fee_per_gas: u64,
    }
    impl<'a> Default for ETHTransactionArgs<'a> {
        #[inline]
        fn default() -> Self {
            ETHTransactionArgs {
                chain_id: 0,
                to: None,
                value: 0,
                nonce: 0,
                gas: 0,
                max_fee_per_gas: 0,
                max_priority_fee_per_gas: 0,
            }
        }
    }

    pub struct ETHTransactionBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ETHTransactionBuilder<'a, 'b> {
        #[inline]
        pub fn add_chain_id(&mut self, chain_id: u64) {
            self.fbb_
                .push_slot::<u64>(ETHTransaction::VT_CHAIN_ID, chain_id, 0);
        }
        #[inline]
        pub fn add_to(&mut self, to: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ETHTransaction::VT_TO, to);
        }
        #[inline]
        pub fn add_value(&mut self, value: u64) {
            self.fbb_
                .push_slot::<u64>(ETHTransaction::VT_VALUE, value, 0);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u32) {
            self.fbb_
                .push_slot::<u32>(ETHTransaction::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_gas(&mut self, gas: u64) {
            self.fbb_.push_slot::<u64>(ETHTransaction::VT_GAS, gas, 0);
        }
        #[inline]
        pub fn add_max_fee_per_gas(&mut self, max_fee_per_gas: u64) {
            self.fbb_
                .push_slot::<u64>(ETHTransaction::VT_MAX_FEE_PER_GAS, max_fee_per_gas, 0);
        }
        #[inline]
        pub fn add_max_priority_fee_per_gas(&mut self, max_priority_fee_per_gas: u64) {
            self.fbb_.push_slot::<u64>(
                ETHTransaction::VT_MAX_PRIORITY_FEE_PER_GAS,
                max_priority_fee_per_gas,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ETHTransactionBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ETHTransactionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ETHTransaction<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ETHTransaction<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ETHTransaction");
            ds.field("chain_id", &self.chain_id());
            ds.field("to", &self.to());
            ds.field("value", &self.value());
            ds.field("nonce", &self.nonce());
            ds.field("gas", &self.gas());
            ds.field("max_fee_per_gas", &self.max_fee_per_gas());
            ds.field("max_priority_fee_per_gas", &self.max_priority_fee_per_gas());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ETHTransactionT {
        pub chain_id: u64,
        pub to: Option<String>,
        pub value: u64,
        pub nonce: u32,
        pub gas: u64,
        pub max_fee_per_gas: u64,
        pub max_priority_fee_per_gas: u64,
    }
    impl Default for ETHTransactionT {
        fn default() -> Self {
            Self {
                chain_id: 0,
                to: None,
                value: 0,
                nonce: 0,
                gas: 0,
                max_fee_per_gas: 0,
                max_priority_fee_per_gas: 0,
            }
        }
    }
    impl ETHTransactionT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<ETHTransaction<'b>> {
            let chain_id = self.chain_id;
            let to = self.to.as_ref().map(|x| _fbb.create_string(x));
            let value = self.value;
            let nonce = self.nonce;
            let gas = self.gas;
            let max_fee_per_gas = self.max_fee_per_gas;
            let max_priority_fee_per_gas = self.max_priority_fee_per_gas;
            ETHTransaction::create(
                _fbb,
                &ETHTransactionArgs {
                    chain_id,
                    to,
                    value,
                    nonce,
                    gas,
                    max_fee_per_gas,
                    max_priority_fee_per_gas,
                },
            )
        }
    }
    pub enum PaymentURIOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PaymentURI<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PaymentURI<'a> {
        type Inner = PaymentURI<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PaymentURI<'a> {
        pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_MEMO: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PaymentURI { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PaymentURIArgs<'args>,
        ) -> flatbuffers::WIPOffset<PaymentURI<'bldr>> {
            let mut builder = PaymentURIBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.memo {
                builder.add_memo(x);
            }
            if let Some(x) = args.address {
                builder.add_address(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> PaymentURIT {
            let address = self.address().map(|x| x.to_string());
            let amount = self.amount();
            let memo = self.memo().map(|x| x.to_string());
            PaymentURIT {
                address,
                amount,
                memo,
            }
        }

        #[inline]
        pub fn address(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PaymentURI::VT_ADDRESS, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(PaymentURI::VT_AMOUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn memo(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(PaymentURI::VT_MEMO, None)
            }
        }
    }

    impl flatbuffers::Verifiable for PaymentURI<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "address",
                    Self::VT_ADDRESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("memo", Self::VT_MEMO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PaymentURIArgs<'a> {
        pub address: Option<flatbuffers::WIPOffset<&'a str>>,
        pub amount: u64,
        pub memo: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for PaymentURIArgs<'a> {
        #[inline]
        fn default() -> Self {
            PaymentURIArgs {
                address: None,
                amount: 0,
                memo: None,
            }
        }
    }

    pub struct PaymentURIBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PaymentURIBuilder<'a, 'b> {
        #[inline]
        pub fn add_address(&mut self, address: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PaymentURI::VT_ADDRESS, address);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(PaymentURI::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_memo(&mut self, memo: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(PaymentURI::VT_MEMO, memo);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PaymentURIBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PaymentURIBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PaymentURI<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PaymentURI<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PaymentURI");
            ds.field("address", &self.address());
            ds.field("amount", &self.amount());
            ds.field("memo", &self.memo());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct PaymentURIT {
        pub address: Option<String>,
        pub amount: u64,
        pub memo: Option<String>,
    }
    impl Default for PaymentURIT {
        fn default() -> Self {
            Self {
                address: None,
                amount: 0,
                memo: None,
            }
        }
    }
    impl PaymentURIT {
        pub fn pack<'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
        ) -> flatbuffers::WIPOffset<PaymentURI<'b>> {
            let address = self.address.as_ref().map(|x| _fbb.create_string(x));
            let amount = self.amount;
            let memo = self.memo.as_ref().map(|x| _fbb.create_string(x));
            PaymentURI::create(
                _fbb,
                &PaymentURIArgs {
                    address,
                    amount,
                    memo,
                },
            )
        }
    }
} // pub mod fb
